<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0,user-scalable=no"/><link rel="shortcut icon" href="/favicon.ico" /><title>Vue 学习总结 - Xheldon</title><meta name="author" content="Xheldon" /><meta name="description" content="Vue 学习总结" /><meta name="keywords" content="Vue 学习总结, Xheldon, Framework" /><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"><meta content="" property="fb:app_id"><meta content="Xheldon" property="og:site_name"><meta content="Vue 学习总结" property="og:title"><meta content="article" property="og:type"><meta content="会点前端，在学 Node、Electron、ProseMirror" property="og:description"><meta content="https://xheldon.com/tech/vue-learning-summary.html" property="og:url"><meta content="2016-06-01T13:22:21+00:00" property="article:published_time"><meta content="https://xheldon.com/about/" property="article:author"><meta content="/resource/img/logo_min.png" property="og:image"><meta content="Framework" property="article:section"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@"><meta name="twitter:title" content="Vue 学习总结"><meta name="twitter:url" content="https://xheldon.com/tech/vue-learning-summary.html"><meta name="twitter:description" content="会点前端，在学 Node、Electron、ProseMirror"><style type="text/css"> /* Project Elements */ .project-outer { display: inline-block; min-width: 30%; max-width: 45%; vertical-align: top; margin: 0 1.6%; overflow: hidden; } .project-img img { width: 100%; } h3.project-headlines { margin: 5px 0; font-size: 20px; } span.tags { font-size: 10px; border-bottom: 1px #888 dotted; margin: 0 5px; } span.tags:first-child { margin-left: 0; } span.tags:last-child { margin-right: 0; } .project-footer { clear: both; display: inline-block; width: 100%; } .project-footer .project-link { display: inline-block; position: relative; float: left; text-decoration: none; } .project-footer .project-timeline { display: inline-block; position: relative; float: right; font-size: 13px; font-style: italic; } .project-inner>a { display: block; } .project-img { width: 100%; height: 200px; display: block; background-size: contain; background-repeat: no-repeat; background-position: center center; } /** Project Tag Filters **/ .tag-group { margin: 0 0 25px 0; } span.tag-cloud { margin: 0 2px; cursor: pointer; font-size: 75%; padding: .2em .6em .3em; font-weight: 700; display: inline; } .tag-cloud.active { background: #ccc; } .project-item.not-show { display: none; } a.project-detail:hover { text-decoration: none; } a.project-detail:hover h3 { color: #428bca; }</style><link rel="stylesheet" href="/resource/css/main.css?t=20190911161844"><body><div class="container" id="container-post"><header id="header-post"> <a href="/"><img class="profile-avatar" src="/resource/img/logo_min.png" height="75px" width="75px" /></a><nav class="navlinks"><li><a class="about" href="https://42.xheldon.com/about/">我</a><li><a class="about" href="/book-list/">书单</a><li><a class="about" href="/projects/">项目</a><li><a class="about" href="/donate/">赞赏</a><li><a class="about" href="/feed.xml">订阅</a></nav><div class="search" id="js-search"> <input type="text" placeholder="搜索一下" class="search__input form-control" id="js-search__input"><ul class="search__results" id="js-search__results"></ul></div></header><main class="main-layout" id="page-post"><aside id="toc"><ul id="my_toc"><li><a href="#前言">前言</a><li><a href="#vue-实例">Vue 实例</a><li><a href="#props-vs-data">props vs data</a><li><a href="#指令和参数属性">指令和参数(属性)</a><li><a href="#过滤器">过滤器</a><li><a href="#列表渲染">列表渲染</a><li><a href="#事件处理器">事件处理器</a><li><a href="#表单控件">表单控件</a><li><a href="#组件">组件</a><li><a href="#字面量语法-vs-动态语法">字面量语法 VS 动态语法</a><li><a href="#异步更新队列">异步更新队列</a><li><a href="#动画">动画</a><li><a href="#render-函数"><code class="language-plaintext highlighter-rouge">render</code> 函数</a><li><a href="#其他">其他</a><li><a href="#服务端渲染server-side-render">服务端渲染(<code class="language-plaintext highlighter-rouge">Server Side Render</code>)</a><li><a href="#后记">后记</a></ul></aside><article class="post"><section class="post-header"><h1 class="post-title">Vue 学习总结</h1><div> <time class="time">2016年06月01日</time> <span class="categories"> &raquo; <a href="/category/Framework">Framework</a> </span></div></section><div class="time-tips">注意：离本文创建时间已经过去了 <code>1862</code> 天, 请注意时效性</div><h2 id="前言">前言</h2><p>这篇文章从 <a href="https://cn.vuejs.org/v2/guide/instance.html"><code class="language-plaintext highlighter-rouge">Vue 2.0官方文档</code></a> 的”实例”一节开始, 研究一些 <code class="language-plaintext highlighter-rouge">Vue API</code> 的使用方法, 以及 <code class="language-plaintext highlighter-rouge">Vue</code> 实现一些功能的原理, 此外还有自己的使用感受, 以及站在自己浅薄的角度分析 <code class="language-plaintext highlighter-rouge">Vue</code> 为什么要这么设计的不敬之举, 如有得罪还请海涵, 刚接触 <code class="language-plaintext highlighter-rouge">Vue</code> 不久, 不当之处烦请指出, 先行谢过.<blockquote><p>注意: 基础知识直接略过, 我只说我认为需要说的点.</blockquote><h2 id="vue-实例">Vue 实例</h2><p>每个 <code class="language-plaintext highlighter-rouge">Vue.js</code> 的应用都是通过构造函数创建一个 <code class="language-plaintext highlighter-rouge">Vue</code> 的根实例启动的, 意思就是, 每个页面的数据都应该只由这一个实例维护, 原始数据的来源都应该只由根实例来发出和接收统一管理, 根实例再通过 <code class="language-plaintext highlighter-rouge">props</code>, 分发数据, 或者 <code class="language-plaintext highlighter-rouge">events</code> 来监听数据. 子组件只需要 <code class="language-plaintext highlighter-rouge">watch/computed</code> 数据变化, 及时更新即可.<p>文档中说了一句话叫: <code class="language-plaintext highlighter-rouge">所有的 Vue.js 组件其实都是被扩展的 Vue 实例</code>, 这句话正确理解起来应该是, 你可以在组件上使用和实例一样的方法和钩子函数, 除了 <code class="language-plaintext highlighter-rouge">data</code> .<p>组件中的 <code class="language-plaintext highlighter-rouge">data</code>, 必须是一个函数, 因为组件会被复用, 所以必须每次调用组件都生成一份数据.<p>数据代理(proxy), 指的是 <code class="language-plaintext highlighter-rouge">Vue</code> 实例会代理其 <code class="language-plaintext highlighter-rouge">data</code> 对象中的所有属性, 而实例属性 <code class="language-plaintext highlighter-rouge">$data</code> 则表示 <code class="language-plaintext highlighter-rouge">data</code> 属性本身, 以区别被代理的 <code class="language-plaintext highlighter-rouge">data</code>.<p>意思是, 如果一个 <code class="language-plaintext highlighter-rouge">vm</code> 的 <code class="language-plaintext highlighter-rouge">data</code> 属性为 <code class="language-plaintext highlighter-rouge">{a: 'xheldon'}</code>, 那么 <code class="language-plaintext highlighter-rouge">vm.a</code> 即为 <code class="language-plaintext highlighter-rouge">'xheldon'</code>, 而 <code class="language-plaintext highlighter-rouge">vm.$data</code> 则为 <code class="language-plaintext highlighter-rouge">{a: 'xheldon'}</code>.<p>组件其实也是一个(被扩展的) <code class="language-plaintext highlighter-rouge">Vue</code> 实例, 下面是个简单的验证:<p>有一个 <code class="language-plaintext highlighter-rouge">list.vue</code> 组件(<code class="language-plaintext highlighter-rouge">template</code> 和 <code class="language-plaintext highlighter-rouge">style</code> 省略):<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Vue</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">vue</span><span class="dl">'</span>
<span class="k">export</span> <span class="k">default</span><span class="p">{</span>
  <span class="nx">data</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Vue</span><span class="p">);</span><span class="c1">//true</span>
    <span class="k">return</span> <span class="p">{}</span>
  <span class="p">}</span>
  <span class="nl">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">com-list</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="props-vs-data">props vs data</h2><p>初始化组件的时候, <code class="language-plaintext highlighter-rouge">prop</code> 上的属性和 <code class="language-plaintext highlighter-rouge">data</code> 上的属性以及 <code class="language-plaintext highlighter-rouge">computed</code> 的方法, 都被绑定到 <code class="language-plaintext highlighter-rouge">Vue</code> 实例上了, 但是 <code class="language-plaintext highlighter-rouge">porps</code> 上的属性, 优先级比 <code class="language-plaintext highlighter-rouge">data</code> 同名属性要高,下面是验证:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span><span class="p">{</span>
  <span class="nx">data</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">first:</span><span class="dl">'</span><span class="p">,</span><span class="k">this</span><span class="p">);</span><span class="c1">//list 的实例</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">a</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span><span class="c1">//属性 a 代表的值挂在 data 上, 但是被下面的 prop 属性同名覆盖(查看上面控制台输出的内容即可)</span>
      <span class="na">d</span><span class="p">:</span> <span class="dl">'</span><span class="s1">d</span><span class="dl">'</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="na">props</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">],</span><span class="c1">//和 data 中的 a 属性同名, 因此来自父级的数据将 data 中的同名属性 a 上的数据覆盖.(注:父级是根组件, 挂载在一个实例上)</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">com-list</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div><p>结果出现警告(不是报错, 不影响渲染):<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nx">Vue</span> <span class="nx">warn</span><span class="p">]:</span> <span class="nx">The</span> <span class="nx">data</span> <span class="nx">property</span> <span class="dl">"</span><span class="s2">a</span><span class="dl">"</span> <span class="nx">is</span> <span class="nx">already</span> <span class="nx">declared</span> <span class="k">as</span> <span class="nx">a</span> <span class="nx">prop</span><span class="p">.</span> <span class="nx">Use</span> <span class="nx">prop</span> <span class="k">default</span> <span class="nx">value</span> <span class="nx">instead</span><span class="p">.</span>
</code></pre></div></div><p><img src="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/img/2016/propsVSdata.png" alt="props VS data" title="props VS data" /><p>而 <code class="language-plaintext highlighter-rouge">computed</code> 返回的函数名和 <code class="language-plaintext highlighter-rouge">data</code> 上的属性名可以重复, 并且不会有任何提示, 但是同名覆盖了之后, 因为在初始化的时候, 从控制台可以看到 <code class="language-plaintext highlighter-rouge">_data</code> 后于 <code class="language-plaintext highlighter-rouge">_computedWatcher</code> 来设置这个重复属性的 <code class="language-plaintext highlighter-rouge">getter</code> 和 <code class="language-plaintext highlighter-rouge">setter</code>(不知道是不是这个原因, 先放在这个地方以待我深入研究之后再修改这篇文章), 因此导致了被覆盖. 相关原理可以 <a href="https://juejin.im/entry/577639de165abd00547b0924">看这篇介绍</a><p>它们都在初始化的时候绑定到了实例 <code class="language-plaintext highlighter-rouge">属性</code> 上, 同名的 <code class="language-plaintext highlighter-rouge">computed</code> 属性被覆盖了, 但是 <code class="language-plaintext highlighter-rouge">Vue devtool</code> 仍然正确显示了出来)<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span><span class="p">{</span>
  <span class="nx">data</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">first:</span><span class="dl">'</span><span class="p">,</span><span class="k">this</span><span class="p">);</span><span class="c1">//list 的实例</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">ab</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span><span class="c1">//属性 a 代表的值挂在 data 上, 但是被下面的 prop 属性同名覆盖(查看上面控制台输出的内容即可)</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="na">computed</span><span class="p">:</span> <span class="p">{</span>
    <span class="nx">ab</span><span class="p">(){</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">computed a</span><span class="dl">'</span><span class="p">;</span><span class="c1">//方法名跟 data 上的 a 属性同名, 因此console 出来的 this 不会出现它的值, 用花括号输出的时候也是输出的 data 上的同名属性</span>
    <span class="p">},</span>
    <span class="nx">f</span><span class="p">(){</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">computed f</span><span class="dl">'</span><span class="c1">//方法名没有重复的, 因此 console 出来的 this 会有它的同名属性, 且值为 'computed f', 我们提供的 function 被作为该属性的 getter(计算属性默认只有 getter, 可以手动添加 setter)</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">com-list</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div><p><img src="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/img/2016/computedVSdata1.png" alt="computed VS data" title="computed VS data" /><p><code class="language-plaintext highlighter-rouge">Vue devtool</code> 正确显示了出来:<p><img src="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/img/2016/computedVSdata3.png" alt="computed VS data" title="computed VS data" /><p>如果 <code class="language-plaintext highlighter-rouge">computed</code> 上的方法名和 <code class="language-plaintext highlighter-rouge">data</code> 上的属性名不重复:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span><span class="p">{</span>
  <span class="nx">data</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">first:</span><span class="dl">'</span><span class="p">,</span><span class="k">this</span><span class="p">);</span><span class="c1">//list 的实例</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">a</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span><span class="c1">//属性 a 代表的值挂在 data 上, 但是被下面的 prop 属性同名覆盖(查看上面控制台输出的内容即可)</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="na">computed</span><span class="p">:</span> <span class="p">{</span>
    <span class="nx">ab</span><span class="p">(){</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">computed a</span><span class="dl">'</span><span class="p">;</span><span class="c1">//方法名跟 data 上的 a 属性同名, 因此 console 出来的 this 不会出现它的值, 但 Vue devtool 控制台正确显示了出来, 用花括号输出的时候也是其返回值 computed a.</span>
    <span class="p">},</span>
    <span class="nx">f</span><span class="p">(){</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">computed f</span><span class="dl">'</span><span class="c1">//方法名没有重复的, 因此 console 出来的 this 会有它的同名属性, 且值为 'computed f', 我们提供的 function 被作为该属性的 getter</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">com-list</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div><p><img src="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/img/2016/computedVSdata2.png" alt="computed VS data" title="computed VS data" /><p>此外, <code class="language-plaintext highlighter-rouge">methods</code> 和 <code class="language-plaintext highlighter-rouge">computed</code> 方法的区别除了后者有缓存而前者没有外(即后者除非其所依赖的响应式数据发生变化, 否则不会重新计算), 如果两者均是为了返回插值的话,则 <code class="language-plaintext highlighter-rouge">methods</code> 上的方法使用是 <code class="language-plaintext highlighter-rouge">functionName()</code>, 而 <code class="language-plaintext highlighter-rouge">computed</code> 上的方法引用是 <code class="language-plaintext highlighter-rouge">functionName</code>, 即前者需要执行函数, 后者不需要执行.<p>究其原因, 是因为 <code class="language-plaintext highlighter-rouge">computed</code> 属性上的我们写的方法, 被当做一个属性, 挂载到 <code class="language-plaintext highlighter-rouge">Vue</code> 实例上了, 而我们提供的函数, 被当做此方法的 <code class="language-plaintext highlighter-rouge">getter</code>.<p>而 <code class="language-plaintext highlighter-rouge">methods</code> 不同, 它就是一个函数, 因此无论是插值引用, 还是事件方法, 都需要使用()来调用.<p>这样的话, 当需要真正的函数——这里如果使用函数调用, 则 <code class="language-plaintext highlighter-rouge">computed</code> 需要返回一个函数不仅仅指是返回一个值, 而是需要传递参数——的时候, <code class="language-plaintext highlighter-rouge">metohds</code> 首当其冲.<p>下面是一个不同于官网的另一个版本的 <code class="language-plaintext highlighter-rouge">todo list</code>:<p>模板:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;template&gt;</span>
  <span class="nt">&lt;div&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span>
  <span class="err">@</span><span class="na">keyup.enter=</span><span class="s">"addToList"</span>
  <span class="na">v-model=</span><span class="s">"todotext"</span>
  <span class="nt">/&gt;</span>
  <span class="nt">&lt;ul&gt;</span>
  
    <span class="nt">&lt;li</span> <span class="na">v-for=</span><span class="s">"(value, key) in todolist"</span><span class="nt">&gt;</span>
    {{key}}:{{value}}<span class="nt">&lt;button</span> <span class="err">@</span><span class="na">click=</span><span class="s">"deletetodo(key)"</span><span class="nt">&gt;</span>X<span class="nt">&lt;/button&gt;&lt;/li&gt;</span>
  
  <span class="nt">&lt;/ul&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/template&gt;</span>
</code></pre></div></div><p>逻辑:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span><span class="p">{</span>
  <span class="nx">data</span><span class="p">(){</span>
    <span class="k">return</span><span class="p">{</span>
      <span class="na">todolist</span><span class="p">:[],</span>
      <span class="na">todotext</span><span class="p">:</span><span class="dl">''</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="na">methods</span><span class="p">:</span> <span class="p">{</span>
    <span class="nx">addToList</span><span class="p">(){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">todolist</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">todotext</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="nx">deletetodo</span><span class="p">(</span><span class="nx">key</span><span class="p">){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">todolist</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span><span class="cm">/*,
  computed:{
    deletetodo(key){//不接收参数
      console.log(arguments);
      this.todolist.splice(key, 1);
    }
  }*/</span>
<span class="p">}</span>
</code></pre></div></div><p>此例子中, 如果使用这种模板, 则需要传递一个参数, 以在点击 <code class="language-plaintext highlighter-rouge">button</code> 的时候删除当前 <code class="language-plaintext highlighter-rouge">li</code>, 因此这个情况必须使用 <code class="language-plaintext highlighter-rouge">methods</code>.<p>使用 <code class="language-plaintext highlighter-rouge">computed</code> 的时候, 不接受参数 <a href="http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments">(因为是一个 <code class="language-plaintext highlighter-rouge">getter</code>)</a>, 即使其返回一个 <code class="language-plaintext highlighter-rouge">function</code> :<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">computed</span><span class="p">:{</span>
  <span class="nx">deletetodo</span><span class="p">(</span><span class="nx">key</span><span class="p">){</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span><span class="c1">//控制台输出当前组件实例</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">todolist</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//报错</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>注意: 若两者存在同名函数, 那么 <code class="language-plaintext highlighter-rouge">computed</code> 上的函数优先级比 <code class="language-plaintext highlighter-rouge">methods</code> 高(处理 <code class="language-plaintext highlighter-rouge">getter</code> 和 <code class="language-plaintext highlighter-rouge">setter</code> 先后顺序的问题, 具体可查看源码), 这个情况无论是对插值还是事件绑定都适用, 以下是验证:<p>插值引用测试:<p>模板:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nt">&lt;div&gt;</span>{{a()}}<span class="nt">&lt;/div&gt;</span>

</code></pre></div></div><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">methods</span><span class="p">:{</span>
  <span class="nx">a</span><span class="p">(){</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">im from methods</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">},</span>
<span class="nx">computed</span><span class="p">:{</span>
  <span class="nx">a</span><span class="p">(){</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">im from computed</span><span class="dl">'</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>输出函数 <code class="language-plaintext highlighter-rouge">im from computed</code>, 如果 <code class="language-plaintext highlighter-rouge">computed</code> 不返回函数, 插值引用只使用 <code class="language-plaintext highlighter-rouge">{{a}}</code> 则显而易见更是输出 <code class="language-plaintext highlighter-rouge">computed</code> 的值, 验证此处略.<p>事件绑定的时候:<p>调用的时候使用 <a href="https://cn.vuejs.org/v2/guide/events.html#内联处理器方法">内联处理器方法</a>:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nt">&lt;div</span> <span class="err">@</span><span class="na">click=</span><span class="s">"a()"</span><span class="nt">&gt;</span>click me<span class="nt">&lt;/div&gt;</span>

</code></pre></div></div><p>逻辑:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">methods</span><span class="p">:{</span>
  <span class="nx">a</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">methods</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">},</span>
<span class="nx">computed</span><span class="p">:{</span>
  <span class="nx">a</span><span class="p">(){</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span><span class="c1">//computed 返回一个函数</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">computed</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>输出 <code class="language-plaintext highlighter-rouge">computed</code><p>如果使用 <a href="https://cn.vuejs.org/v2/guide/events.html#方法事件处理器">方法事件处理器</a>, 结果一样:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nt">&lt;div</span> <span class="err">@</span><span class="na">click=</span><span class="s">"a"</span><span class="nt">&gt;</span>click me<span class="nt">&lt;/div&gt;</span>//注意此处不带括号

</code></pre></div></div><p>逻辑:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">methods</span><span class="p">:{</span>
  <span class="nx">a</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">methods</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">},</span>
<span class="nx">computed</span><span class="p">:{</span>
  <span class="nx">a</span><span class="p">(){</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span><span class="c1">//computed 返回一个函数</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">computed</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>输出 <code class="language-plaintext highlighter-rouge">computed</code><p>注意事件绑定的时候, <code class="language-plaintext highlighter-rouge">computed</code> 都需要返回一个函数.<p>因此优先级的顺序是:<p><code class="language-plaintext highlighter-rouge">porps &gt; data &gt; computed &gt; methods</code><p>我猜测在 <code class="language-plaintext highlighter-rouge">computed</code> 和 <code class="language-plaintext highlighter-rouge">methods</code> 中的 <code class="language-plaintext highlighter-rouge">this.xxx</code> 中的引用优先级也是相同的, 想搞明白的可以去验证下.<p>而且可以看到, 两种情况 <code class="language-plaintext highlighter-rouge">method</code> 都不用返回一个 <code class="language-plaintext highlighter-rouge">function</code> , 而两种情况 <code class="language-plaintext highlighter-rouge">computed</code> 都需要返回一个 <code class="language-plaintext highlighter-rouge">function</code> 而且都不接受参数(因为是 <code class="language-plaintext highlighter-rouge">getter</code>). 综上所述, 事件处理最好使用 <code class="language-plaintext highlighter-rouge">methods</code>, 而数据绑定/插值处理 最好使用 <code class="language-plaintext highlighter-rouge">computed</code>(因为有缓存).<p>此外, 对于 <code class="language-plaintext highlighter-rouge">method</code> 绑定事件的时候, 带()和不带()的效果是一样的, 都会执行其函数, 区别有以下几个:<ol><li><code class="language-plaintext highlighter-rouge">带()的叫内联语句</code>, 分两种情况, 原生事件和自定义事件. 两种情况都可以传参, 如果参数列表为空, 则默认参数 <code class="language-plaintext highlighter-rouge">arguments</code> 也为空, 即不存在默认参数; 如果是被一个原生事件如 <code class="language-plaintext highlighter-rouge">input/click</code> 触发的, 则可以传递一个特殊的 <code class="language-plaintext highlighter-rouge">$event</code> 参数作为原生 <code class="language-plaintext highlighter-rouge">event</code> 事件处理; 而如果是被一个自定义事件触发的, 其事件处理函数的参数仍然取决于实际传递给事件处理函数的值, 而且自定义函数不存在特殊的 <code class="language-plaintext highlighter-rouge">$event</code> 对象供使用. 由 <code class="language-plaintext highlighter-rouge">$emit</code> 触发自定义事件时传递的参数将被忽略.<li><code class="language-plaintext highlighter-rouge">不带()叫方法事件</code>, 则分两种情况: 如果是原生事件, 则会传递原生 <code class="language-plaintext highlighter-rouge">event</code> 事件作为唯一的默认参数; 如果是自定义事件, 则传递的是 <code class="language-plaintext highlighter-rouge">$emit</code> 事件的时候除了事件名外的第二到最后一个任意数量的参数.</ol><blockquote><p>talk is cheap, show me the code</blockquote><p>上面说的是四个情况:<p>1.带()的原生事件<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="p">@</span><span class="nd">click</span><span class="o">=</span><span class="dl">"</span><span class="s2">test1()</span><span class="dl">"</span><span class="o">&gt;</span><span class="c1">//模板里面传参为空</span>
<span class="nx">methods</span><span class="p">:{</span>
  <span class="nx">test1</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span><span class="c1">//则逻辑中的参数也为空;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>2.带()的自定义事件<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//子模板</span>
<span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="p">@</span><span class="nd">input</span><span class="o">=</span><span class="dl">"</span><span class="s2">shuru($event)</span><span class="dl">"</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="c1">//子逻辑:</span>
<span class="nx">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">child</span><span class="dl">'</span><span class="p">,</span>
<span class="nx">props</span><span class="p">:[</span><span class="dl">'</span><span class="s1">xheldon</span><span class="dl">'</span><span class="p">],</span>
<span class="nx">method</span><span class="p">:{</span>
  <span class="nx">shuru</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">haha</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span><span class="dl">'</span><span class="s1">其他参数</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//父模板</span>
<span class="o">&lt;</span><span class="nx">child</span> <span class="p">:</span><span class="nx">xheldon</span><span class="o">=</span><span class="dl">"</span><span class="s2">blob</span><span class="dl">"</span> <span class="p">@</span><span class="nd">haha</span><span class="o">=</span><span class="dl">"</span><span class="s2">something()</span><span class="dl">"</span><span class="o">&gt;&lt;</span><span class="sr">/child</span><span class="err">&gt;
</span><span class="c1">//父逻辑:</span>
<span class="nx">methods</span><span class="p">:{</span>
  <span class="nx">something</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">parent:</span><span class="dl">'</span><span class="p">,...</span><span class="nx">arguments</span><span class="p">);</span><span class="c1">//上面 something() 中传 xxx, 则输出 'parent:xxx', 即忽略了子组件 $emit 事件时候传递的参数.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">blob</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>3.不带()的原生事件<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="p">@</span><span class="nd">click</span><span class="o">=</span><span class="dl">"</span><span class="s2">test1</span><span class="dl">"</span><span class="o">&gt;</span>
<span class="nx">methods</span><span class="p">:{</span>
  <span class="nx">test1</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span><span class="c1">//结果: 输出原生的 MouseEvent 事件</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>4.不带()的自定义事件<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//子模板</span>
<span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="p">@</span><span class="nd">input</span><span class="o">=</span><span class="dl">"</span><span class="s2">shuru($event)</span><span class="dl">"</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="c1">//子逻辑:</span>
<span class="nx">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">child</span><span class="dl">'</span><span class="p">,</span>
<span class="nx">props</span><span class="p">:[</span><span class="dl">'</span><span class="s1">xheldon</span><span class="dl">'</span><span class="p">],</span>
<span class="nx">method</span><span class="p">:{</span>
  <span class="nx">shuru</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">haha</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span><span class="dl">'</span><span class="s1">其他参数</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//父模板</span>
<span class="o">&lt;</span><span class="nx">child</span> <span class="p">:</span><span class="nx">xheldon</span><span class="o">=</span><span class="dl">"</span><span class="s2">blob</span><span class="dl">"</span> <span class="p">@</span><span class="nd">haha</span><span class="o">=</span><span class="dl">"</span><span class="s2">something</span><span class="dl">"</span><span class="o">&gt;&lt;</span><span class="sr">/child</span><span class="err">&gt;
</span><span class="c1">//父逻辑:</span>
<span class="nx">methods</span><span class="p">:{</span>
  <span class="nx">something</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">parent:</span><span class="dl">'</span><span class="p">,...</span><span class="nx">arguments</span><span class="p">);</span><span class="c1">//input 输入 xxx, 则输出 'parent: xxx 其他参数', 即与子组件 $emit 时候传递的参数相关.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">blob</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="指令和参数属性">指令和参数(属性)</h2><p>基本用法:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">v-directive:propNamed.modifiers=</span><span class="s">"value"</span><span class="nt">&gt;&lt;/div&gt;</span>
</code></pre></div></div><p>其中, <code class="language-plaintext highlighter-rouge">directive</code> 叫做指令, <code class="language-plaintext highlighter-rouge">propName</code> 叫做指令的”参数”, 实际上参数的具体表现就是 <code class="language-plaintext highlighter-rouge">html</code> 上的属性(<code class="language-plaintext highlighter-rouge">Vue</code> 内置了一些参数/属性, 如 <code class="language-plaintext highlighter-rouge">v-bind:click="method"</code>, 的 <code class="language-plaintext highlighter-rouge">click</code>, 如 <code class="language-plaintext highlighter-rouge">v-bind:href="/img/x.png"</code> 的 <code class="language-plaintext highlighter-rouge">href</code>, 前者不会出现在行内, 而后者因为是必须的因此会出现在行内属性. 而自己定义的参数/属性, 一定会出现在行内属性). 而 <code class="language-plaintext highlighter-rouge">value</code> 是个变量(虽然它写在双引号中)大多数情况下来自于父级模板.<p><code class="language-plaintext highlighter-rouge">propName</code> 可以带个修饰符, 用来快捷操作一些行为如禁止默认事件 <code class="language-plaintext highlighter-rouge">.prevent</code> 等.<p>有些指令可以直接使用如 <code class="language-plaintext highlighter-rouge">v-if</code>, 有些必须加上参数: <code class="language-plaintext highlighter-rouge">v-bind:href/v-on:click</code><p>注意, <code class="language-plaintext highlighter-rouge">value</code> 带不带双引号结果都是一样的, 即 <code class="language-plaintext highlighter-rouge">:propName="value"</code> 和 <code class="language-plaintext highlighter-rouge">:propName=value</code> 是一样的, 除特殊说明, 下列所有情况均适用.<p>如果 <code class="language-plaintext highlighter-rouge">value</code> 转换成布尔值后为 <code class="language-plaintext highlighter-rouge">false</code> 则 <code class="language-plaintext highlighter-rouge">propName</code> 被移除, 为 <code class="language-plaintext highlighter-rouge">true</code> 则该 <code class="language-plaintext highlighter-rouge">propName</code> 出现, 实际上, 它遵守以下规则(仅限自定义属性):<p>1.<code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">undefined</code>, <code class="language-plaintext highlighter-rouge">false</code> 的直接量, <code class="language-plaintext highlighter-rouge">propName</code> 属性被移除. 2.<code class="language-plaintext highlighter-rouge">value</code> 为一个未定义的变量, 如 <code class="language-plaintext highlighter-rouge">:propName="wxd"</code> 则 <code class="language-plaintext highlighter-rouge">propName</code> 移除, 且出现警告:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nx">Vue</span> <span class="nx">warn</span><span class="p">]:</span> <span class="nx">Property</span> <span class="nx">or</span> <span class="nx">method</span> <span class="dl">"</span><span class="s2">s</span><span class="dl">"</span> <span class="nx">is</span> <span class="nx">not</span> <span class="nx">defined</span> <span class="nx">on</span> <span class="nx">the</span> <span class="nx">instance</span> <span class="nx">but</span> <span class="nx">referenced</span> <span class="nx">during</span> <span class="nx">render</span><span class="p">.</span> <span class="nx">Make</span> <span class="nx">sure</span> <span class="nx">to</span> <span class="nx">declare</span> <span class="nx">reactive</span> <span class="nx">data</span> <span class="nx">properties</span> <span class="k">in</span> <span class="nx">the</span> <span class="nx">data</span> <span class="nx">option</span><span class="p">.</span>
</code></pre></div></div><p>3.如果 <code class="language-plaintext highlighter-rouge">value</code> 为一个数组, 因为数组为对象, 因此 <code class="language-plaintext highlighter-rouge">propName</code> 除了下面第二种情况外, 恒存在, 而 <code class="language-plaintext highlighter-rouge">value</code> 分以下情况:<ol><li><p><code class="language-plaintext highlighter-rouge">:propName =[]</code>, <code class="language-plaintext highlighter-rouge">:propName ="[]"</code>, <code class="language-plaintext highlighter-rouge">:propName ="['']"</code> <code class="language-plaintext highlighter-rouge">value</code> 移除, 即只有属性没有值.<li><p><code class="language-plaintext highlighter-rouge">:propName =[""]</code>, 结构乱掉.<li><p><code class="language-plaintext highlighter-rouge">:propName =["",""]</code> 或者 <code class="language-plaintext highlighter-rouge">:propName ='["",""]'</code>, <code class="language-plaintext highlighter-rouge">value</code> 值为<code class="language-plaintext highlighter-rouge">","</code><li><p>如果 <code class="language-plaintext highlighter-rouge">value</code> 为一个嵌套数组, 则其值被一维化后, 如果 <code class="language-plaintext highlighter-rouge">value</code> 包含及其递归子元素包含一个为 <code class="language-plaintext highlighter-rouge">undefined</code> 或者 <code class="language-plaintext highlighter-rouge">null</code> 直接量(不是写到字符串里面的), 则该处的值留空; 如果 <code class="language-plaintext highlighter-rouge">value</code> 包含及其递归子元素包含一个 <code class="language-plaintext highlighter-rouge">Object</code>, 则该处的值为 <code class="language-plaintext highlighter-rouge">[object Object]</code></ol><p>4.如果 <code class="language-plaintext highlighter-rouge">value</code> 为一个对象, 则 <code class="language-plaintext highlighter-rouge">propName</code> 保留, 值为 <code class="language-plaintext highlighter-rouge">[object Object]</code><p>5.如果 <code class="language-plaintext highlighter-rouge">value</code> 为一个数字或者字符串, 如 <code class="language-plaintext highlighter-rouge">:propName = "'fff'"</code>, 则 <code class="language-plaintext highlighter-rouge">propName</code> 保留, <code class="language-plaintext highlighter-rouge">value </code>为字符串或数字值.<p>看了下源码, 也确实是这么个逻辑:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">setAttr</span> <span class="p">(</span><span class="nx">el</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">isBooleanAttr</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// set attribute for blank value</span>
    <span class="c1">// e.g. &lt;option disabled&gt;Select one&lt;/option&gt;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isFalsyAttrValue</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">el</span><span class="p">.</span><span class="nx">removeAttribute</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">el</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isEnumeratedAttr</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">el</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">isFalsyAttrValue</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">||</span> <span class="nx">value</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">false</span><span class="dl">'</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">false</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">true</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isXlink</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isFalsyAttrValue</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">el</span><span class="p">.</span><span class="nx">removeAttributeNS</span><span class="p">(</span><span class="nx">xlinkNS</span><span class="p">,</span> <span class="nx">getXlinkProp</span><span class="p">(</span><span class="nx">key</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">el</span><span class="p">.</span><span class="nx">setAttributeNS</span><span class="p">(</span><span class="nx">xlinkNS</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isFalsyAttrValue</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">el</span><span class="p">.</span><span class="nx">removeAttribute</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">el</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>这些规则仅限自定义属性, 如果是内置属性, 则又不同, 比如绑定 <code class="language-plaintext highlighter-rouge">class</code> 属性:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">v</span><span class="o">-</span><span class="nx">bind</span><span class="p">:</span><span class="kd">class</span><span class="o">=</span><span class="dl">"</span><span class="s2">{active: isActive}</span><span class="dl">"</span>
</code></pre></div></div><p>则表示如果 <code class="language-plaintext highlighter-rouge">isActive</code> 值为是 <code class="language-plaintext highlighter-rouge">false</code> 或者是其他可以转换成布尔值 <code class="language-plaintext highlighter-rouge">false</code> 的值, 则 <code class="language-plaintext highlighter-rouge">active</code> 这个类名不应用, 反之, 则应用该类名(同 if 语句的真假判定一致).<h2 id="过滤器">过滤器</h2><p>过滤器串联起来的话, 第一个过滤器的参数是初始值, 随后的过滤器第一个参数为上一个过滤器的返回值, 没有返回值则为 <code class="language-plaintext highlighter-rouge">undefined</code>.<p>模板:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">v-bind:prop=</span><span class="s">"rawProp | filterOne | filterTwo"</span><span class="nt">&gt;</span>控制台查看 filter 函数的参数<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div><p>逻辑:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">(){</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">rawProp</span><span class="p">:</span> <span class="dl">'</span><span class="s1">this is raw prop</span><span class="dl">'</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="na">filters</span><span class="p">:</span> <span class="p">{</span>
    <span class="nx">filterOne</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">this param is pass to next filter</span><span class="dl">'</span>
    <span class="p">},</span>
    <span class="nx">filterTwo</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
    <span class="p">},</span>
  <span class="p">},</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">com-header</span><span class="dl">'</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div><p>除了第一个 <code class="language-plaintext highlighter-rouge">filter</code> ,后面的 <code class="language-plaintext highlighter-rouge">filter</code> 没有办法获取到初始值. 当然, 如果你想传参数, 办法有的是, 比如第一个 <code class="language-plaintext highlighter-rouge">filter</code> 返回一个数组等等.<h2 id="列表渲染">列表渲染</h2><p><code class="language-plaintext highlighter-rouge">v-for</code> 中, 如果参数是两个, 则是和原生 <code class="language-plaintext highlighter-rouge">js</code> 中的 <code class="language-plaintext highlighter-rouge">forEach</code> 参数一致, 是 <code class="language-plaintext highlighter-rouge">value, key</code>, 而使用 <code class="language-plaintext highlighter-rouge">of</code> 操作符和使用 <code class="language-plaintext highlighter-rouge">in</code> 操作符的效果完全一样——虽然在原生 <code class="language-plaintext highlighter-rouge">js</code> 中并不是.<p>还有个需要注意的地方是, 组件使用 <code class="language-plaintext highlighter-rouge">v-for</code> 的时候, 父级是不能自动传递数据到组件的, 因为组件有自己的独立作用域. 因此你为了传递数据给子组件用, 需要使用 <code class="language-plaintext highlighter-rouge">props</code> 属性写的稍微麻烦一点:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-component</span>
  <span class="na">v-for=</span><span class="s">"(item, index) in items"</span>
  <span class="na">v-bind:item=</span><span class="s">"item"</span>
  <span class="na">v-bind:index=</span><span class="s">"index"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/my-component&gt;</span>
</code></pre></div></div><p>另外, <code class="language-plaintext highlighter-rouge">v-for</code> 使用在对象上面的时候, 迭代值是对象的值, 而不是键, 这个和原生 <code class="language-plaintext highlighter-rouge">js</code> 不一样, 原生 <code class="language-plaintext highlighter-rouge">js</code> 的 <code class="language-plaintext highlighter-rouge">for in</code> 循环若要输出值, 需要你手动遍历 <code class="language-plaintext highlighter-rouge">obj['i']</code>, 而想要输出键需要写第二个参数<code class="language-plaintext highlighter-rouge">(value, key)</code>:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">obj</span><span class="p">:{</span>
  <span class="nl">first</span><span class="p">:</span> <span class="dl">'</span><span class="s1">xheldon</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">last</span><span class="p">:</span> <span class="dl">'</span><span class="s1">cao</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">age</span><span class="p">:</span> <span class="dl">'</span><span class="s1">25</span><span class="dl">'</span>
<span class="p">}</span>
<span class="o">&lt;</span><span class="nx">div</span> <span class="nx">v</span><span class="o">-</span><span class="k">for</span><span class="o">=</span><span class="dl">"</span><span class="s2">(value, key) in obj</span><span class="dl">"</span><span class="o">&gt;</span><span class="p">{{</span><span class="nx">value</span><span class="p">}}</span><span class="o">-</span><span class="p">{{</span><span class="nx">key</span><span class="p">}}</span><span class="o">&lt;</span><span class="sr">/div&gt;/</span><span class="o">/</span> <span class="nx">输出</span> <span class="nx">xheldon</span> <span class="nx">cao</span> <span class="mi">25</span>
</code></pre></div></div><p>注意, 原生 <code class="language-plaintext highlighter-rouge">js</code> 除非你手动实现了一个 <code class="language-plaintext highlighter-rouge">Symbol.iterator</code>, 否则是不能使用 <code class="language-plaintext highlighter-rouge">for of</code> 循环的, 但是 <code class="language-plaintext highlighter-rouge">Vue</code> 可以——虽然效果和 <code class="language-plaintext highlighter-rouge">for in</code> 完全一样.<p>列表渲染还有一个小 <code class="language-plaintext highlighter-rouge">tips</code> 叫就地复用原则, 什么意思呢? 还是拿上面说的 <code class="language-plaintext highlighter-rouge">tololist</code> 说, 如果没有给每个元素指定一个独一无二的 <code class="language-plaintext highlighter-rouge">key</code> 值, 就像这样:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;li</span> <span class="na">v-for=</span><span class="s">"(value, key) in todolist"</span><span class="nt">&gt;</span>{{value.key}}:{{value.value}}<span class="nt">&lt;button</span> <span class="err">@</span><span class="na">click=</span><span class="s">"deletetodo(key)"</span><span class="nt">&gt;</span>X<span class="nt">&lt;/button&gt;&lt;/li&gt;</span>
</code></pre></div></div><p>那么每次点击这个叉叉删除当前 <code class="language-plaintext highlighter-rouge">li</code> 的时候, <code class="language-plaintext highlighter-rouge">Vue</code> 都会就地复用当前的元素, 直接移动数据到正确的位置, 而不是 <code class="language-plaintext highlighter-rouge">remove</code> 删除的 <code class="language-plaintext highlighter-rouge">dom</code> 元素, 避免 <code class="language-plaintext highlighter-rouge">reflow</code>, 下面是使用 <code class="language-plaintext highlighter-rouge">chrome</code> 的 <code class="language-plaintext highlighter-rouge">devtool</code> 工具显示的当点击叉叉删除元素的时候, 页面 <code class="language-plaintext highlighter-rouge">render</code> 的情况:<p><img src="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/img/2016/nokey.png" alt="没有key" title="没有key" /><p>可以看到 <code class="language-plaintext highlighter-rouge">reflow</code> 的部分只有最下面那一点<p>而当加上 <code class="language-plaintext highlighter-rouge">key</code> 之后:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;li</span> <span class="na">v-for=</span><span class="s">"(value, key) in todolist"</span> <span class="na">:key=</span><span class="s">"value.key"</span><span class="nt">&gt;</span>{{value.key}}:{{value.value}}<span class="nt">&lt;button</span> <span class="err">@</span><span class="na">click=</span><span class="s">"deletetodo(key)"</span><span class="nt">&gt;</span>X<span class="nt">&lt;/button&gt;&lt;/li&gt;</span>
</code></pre></div></div><p>再看点击叉叉之后浏览器的 <code class="language-plaintext highlighter-rouge">render</code> 的情况:<p><img src="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/img/2016/key.png" alt="有key" title="有key" /><p>有人可能会有疑惑, 为什么这个地方需要自己手动实现一个 <code class="language-plaintext highlighter-rouge">value</code> 上的 <code class="language-plaintext highlighter-rouge">value.key</code>, 而不是使用 <code class="language-plaintext highlighter-rouge">Vue</code> 给的 <code class="language-plaintext highlighter-rouge">(value, key)</code> 中的 <code class="language-plaintext highlighter-rouge">key</code> 呢?:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nt">&lt;li</span> <span class="na">v-for=</span><span class="s">"(value, key) in todolist"</span> <span class="na">:key=</span><span class="s">"key"</span><span class="nt">&gt;</span>{{value.key}}:{{value.value}}<span class="nt">&lt;button</span> <span class="err">@</span><span class="na">click=</span><span class="s">"deletetodo(key)"</span><span class="nt">&gt;</span>X<span class="nt">&lt;/button&gt;&lt;/li&gt;</span>

</code></pre></div></div><p>答案是, <code class="language-plaintext highlighter-rouge">Vue</code> 给的 <code class="language-plaintext highlighter-rouge">key</code>, 看起来是个 <code class="language-plaintext highlighter-rouge">key</code>, 但是还是跟当前数据是无关的, 因此当删除一个 <code class="language-plaintext highlighter-rouge">li</code> 的时候, <code class="language-plaintext highlighter-rouge">key</code> 仅仅只是重新算了一下, 并没有跟着删除的或者被删除的元素移除或者上移下移. 如果使用上面的写法, 效果和第一种没有 <code class="language-plaintext highlighter-rouge">key</code> 的是一样的, 仍然使用了就地复用策略, 变动的还是数据, 不变的还是 <code class="language-plaintext highlighter-rouge">dom</code> 结构, 因此你需要手动实现一个 <code class="language-plaintext highlighter-rouge">key</code>, 大致是这样的:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span><span class="p">(){</span>
  <span class="k">return</span><span class="p">{</span>
    <span class="na">toolist</span><span class="p">:[],</span>
    <span class="na">truekey</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span><span class="c1">//手动实现一个 key</span>
    <span class="na">todotext</span><span class="p">:</span> <span class="dl">''</span>
  <span class="p">}</span>
<span class="p">},</span>
<span class="nx">methods</span><span class="p">:</span> <span class="p">{</span>
  <span class="nx">addTolist</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">todolist</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="na">value</span><span class="p">:</span><span class="k">this</span><span class="p">.</span><span class="nx">todotext</span><span class="p">,</span> <span class="na">key</span><span class="p">:</span> <span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="nx">truekey</span><span class="p">});</span><span class="c1">// 把 key 放到 data 上</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="事件处理器">事件处理器</h2><p>事件处理器可以串联, 但是有些元素本身不支持, 因此绑定了也没有意义, 如在 <code class="language-plaintext highlighter-rouge">div</code> 上绑定一个 <code class="language-plaintext highlighter-rouge">keyup</code> 事件:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">div</span> <span class="p">@</span><span class="nd">keyup</span><span class="p">.</span><span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">pressalt</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">div</span> <span class="nx">alt</span> <span class="nx">按键测试</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div></div><p>因此一般是在 <code class="language-plaintext highlighter-rouge">div</code> 上冒泡处理事件, 然后在一个 <code class="language-plaintext highlighter-rouge">input</code> 上绑定一个 <code class="language-plaintext highlighter-rouge">alt+ctrl</code> 事件:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">div</span> <span class="p">@</span><span class="nd">keyup</span><span class="p">.</span><span class="nx">alt</span><span class="o">=</span><span class="dl">"</span><span class="s2">presskey</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">div冒泡按键测试</span>
  <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div></div><p>我对此有个担心, 就是如果一个 <code class="language-plaintext highlighter-rouge">input</code> 使用了 <code class="language-plaintext highlighter-rouge">@keyup.space</code> 的监听, 但是中文输入法中空格一般是用来选中词语的, 那实际输出的是还未选中词语的拼音字母, 还是按下空格后, 候选列表的第一个词语呢?(貌似这个不是 <code class="language-plaintext highlighter-rouge">Vue</code> 的问题, 但是还是在这儿提出来了)<p>答案是, 大多数情况下, 结果是按下空格后的第一个词语, 但是如果一句话很长的话, 需要按两次 <code class="language-plaintext highlighter-rouge">space</code> 来输出一句话, 则第一次按的时候, 什么也不会输出, 是个空的, 第二次按下 <code class="language-plaintext highlighter-rouge">space</code> 才输出全部的词汇. 我这里是为了测试的极端情况, 因此基本可以认为按下空格后的第一个词语, 而不是空白, 或者拼音字母. 我使用的是搜狗 <code class="language-plaintext highlighter-rouge">mac</code> 输入法的单行候选词模式, 可以用上面的 <code class="language-plaintext highlighter-rouge">todolist</code> 来测试(略)<p>注: 官网文档讲 <code class="language-plaintext highlighter-rouge">v-model</code> 的时候会讲到 <code class="language-plaintext highlighter-rouge">IME</code>, 说的就是这个问题, 如果希望使用输入法的时候, <code class="language-plaintext highlighter-rouge">v-model</code> 也即时响应, 那么可以绑定 <code class="language-plaintext highlighter-rouge">input</code> 事件.<h2 id="表单控件">表单控件</h2><p><code class="language-plaintext highlighter-rouge">v-model</code> 一般用在 <code class="language-plaintext highlighter-rouge">input</code> 上面, 而模板中的 <code class="language-plaintext highlighter-rouge">input</code> 的 <code class="language-plaintext highlighter-rouge">value</code> 值会被忽略—— <code class="language-plaintext highlighter-rouge">v-model</code> 只认在 <code class="language-plaintext highlighter-rouge">js</code> 中的初始值, 并与之绑定, 因此如果你写了 <code class="language-plaintext highlighter-rouge">v-model</code>, 又写了 <code class="language-plaintext highlighter-rouge">value</code> 属性, 则后者虽然会出现在 <code class="language-plaintext highlighter-rouge">dom</code> 结构中, 但是 <code class="language-plaintext highlighter-rouge">js</code> 获取其值的时候会忽略掉它而取 <code class="language-plaintext highlighter-rouge">v-model</code> 绑定的值:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">value=</span><span class="s">"我出现在 dom 结构的 value 属性中, 但是只能通过 getAttribute 获取到我, .value 并不能获取到, 伤心~"</span><span class="nt">&gt;</span>
</code></pre></div></div><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span><span class="p">(){</span>
  <span class="k">return</span><span class="p">{</span>
    <span class="na">todotext</span><span class="p">:</span><span class="dl">'</span><span class="s1">我是真正的初始值, js 获取的是我, 虽然我并不出现在 dom 中的 value 属性中~</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>二者的区别类似于 <code class="language-plaintext highlighter-rouge">jQuery</code> 中的, <code class="language-plaintext highlighter-rouge">.data</code> 和 <code class="language-plaintext highlighter-rouge">.attr</code> 的区别——写在行内的是 <code class="language-plaintext highlighter-rouge">attr('data','xxx')</code>的值, 查看 <code class="language-plaintext highlighter-rouge">dom</code> 结构看到的也是 <code class="language-plaintext highlighter-rouge">xxx</code> 的值, 但是 <code class="language-plaintext highlighter-rouge">js</code> 获取到的实际的值是通过 <code class="language-plaintext highlighter-rouge">js</code> 绑定的 <code class="language-plaintext highlighter-rouge">.data('yyy')</code> 的值——当然除非你使用 <code class="language-plaintext highlighter-rouge">attr</code> 读取 <code class="language-plaintext highlighter-rouge">dom</code> 结构.(注意, 实例化之后再修改 <code class="language-plaintext highlighter-rouge">attr</code> 的值, <code class="language-plaintext highlighter-rouge">js</code> 获取到的就是 <code class="language-plaintext highlighter-rouge">attr</code> 的值了, 这里的忽略初始值, 仅仅是忽略初始值而已, 举个例子就是初始化之后的 <code class="language-plaintext highlighter-rouge">v-model</code> 绑定了 <code class="language-plaintext highlighter-rouge">value</code> 之后, 手动修改 <code class="language-plaintext highlighter-rouge">dom</code> 结构的 <code class="language-plaintext highlighter-rouge">value</code> 值, 那 <code class="language-plaintext highlighter-rouge">v-model</code> 再获取该元素的 <code class="language-plaintext highlighter-rouge">value</code> 值就会使用修改后的 <code class="language-plaintext highlighter-rouge">attr</code> 属性值, 而不是 <code class="language-plaintext highlighter-rouge">data</code> 上面的值).<p>如果需求比较奇葩, 不想通过 <code class="language-plaintext highlighter-rouge">v-model</code> 获取 <code class="language-plaintext highlighter-rouge">input</code> 的值, 然后实时更新, 或者需要获取 <code class="language-plaintext highlighter-rouge">input</code> 的值处理后再更新, 同时不想使用 <code class="language-plaintext highlighter-rouge">v-model</code>, 可以试试 <code class="language-plaintext highlighter-rouge">$ref</code>(<code class="language-plaintext highlighter-rouge">e.target.value</code> 也是可以的):<p>模板:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;input</span> <span class="err">@</span><span class="na">input=</span><span class="s">"input"</span> <span class="na">ref=</span><span class="s">"inputvalue"</span> <span class="nt">/&gt;</span>
</code></pre></div></div><p>逻辑:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span><span class="p">(){</span>
  <span class="nl">message</span><span class="p">:</span> <span class="dl">''</span>
<span class="p">},</span>
<span class="nx">methods</span><span class="p">:{</span>
  <span class="nx">input</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$refs</span><span class="p">.</span><span class="nx">inputvalue</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>官网文档也说了, <code class="language-plaintext highlighter-rouge">v-model</code> 只是一个实现双向数据绑定的语法糖:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;input</span> <span class="na">v-bind:value=</span><span class="s">"something"</span> <span class="na">v-on:input=</span><span class="s">"something = $event.target.value"</span><span class="nt">&gt;</span>
</code></pre></div></div><p>不过监听 <code class="language-plaintext highlighter-rouge">input</code> 事件, 导致的问题是使用输入法的时候, 在没按空格选中词语的时候, 也会触发输入的事件, 所以如果没有这个需求, 还是老老实实用 <code class="language-plaintext highlighter-rouge">v-model</code> 的好.<p>如果需要多个元素绑定相同的值并输出, 常见的需求是一组 <code class="language-plaintext highlighter-rouge">checkbox</code>, 这个时候需要使用数组:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;input</span> <span class="na">v-model=</span><span class="s">"messages"</span> <span class="na">type=</span><span class="s">"checkbox"</span> <span class="na">value=</span><span class="s">"xheldon"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;input</span> <span class="na">v-model=</span><span class="s">"messages"</span> <span class="na">type=</span><span class="s">"checkbox"</span> <span class="na">value=</span><span class="s">"xiaodan"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;p&gt;&lt;/p&gt;</span>
</code></pre></div></div><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span><span class="p">(){</span>
  <span class="k">return</span><span class="p">{</span>
    <span class="na">messages</span><span class="p">:</span> <span class="p">[]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>(目前我发现的)这种如此简洁的数组用法仅仅对多个 <code class="language-plaintext highlighter-rouge">checkbox</code> 类型的 <code class="language-plaintext highlighter-rouge">input</code> 有效——即几个元素绑定相同的 <code class="language-plaintext highlighter-rouge">v-model</code>, 但是这几个元素的状态却没有同步, 而是将对应的 <code class="language-plaintext highlighter-rouge">value</code> 放到数组中. 当然如果你强行说, 我用 <code class="language-plaintext highlighter-rouge">methods</code> 方法可以实现任意输入类型的元素完成类似效果——那当我没说.<p>单个的 <code class="language-plaintext highlighter-rouge">checkbox</code> <code class="language-plaintext highlighter-rouge">v-model</code> 绑定的是 <code class="language-plaintext highlighter-rouge">value</code> 值, 为 <code class="language-plaintext highlighter-rouge">true</code> 或者 <code class="language-plaintext highlighter-rouge">false</code>, 可以通过 <code class="language-plaintext highlighter-rouge">:true-value</code> 和 <code class="language-plaintext highlighter-rouge">:false-value</code> 来自定义选中时候的值和没有选中时候的值.<p>而多个单选框 <code class="language-plaintext highlighter-rouge">radio</code> 中的 <code class="language-plaintext highlighter-rouge">v-model</code> 起到了类似 <code class="language-plaintext highlighter-rouge">name</code> 的作用——即用来分组, 所以 <code class="language-plaintext highlighter-rouge">radio</code> 类型的 <code class="language-plaintext highlighter-rouge">input</code> 使用 <code class="language-plaintext highlighter-rouge">v-model</code> 的话就不用写 <code class="language-plaintext highlighter-rouge">name</code> 属性.<p><code class="language-plaintext highlighter-rouge">select</code> 类型的如果没有给定每个 <code class="language-plaintext highlighter-rouge">option</code> 的 <code class="language-plaintext highlighter-rouge">value</code> 属性, 则绑定的是 <code class="language-plaintext highlighter-rouge">option</code> 中的值, 如果给了则就是 <code class="language-plaintext highlighter-rouge">value</code> 的属性值. <code class="language-plaintext highlighter-rouge">select</code> 类型的多选框 <code class="language-plaintext highlighter-rouge">v-model</code> 绑定的 <code class="language-plaintext highlighter-rouge">data</code> 必须是一个数组类型, 否则会给出警告(但不会报错, <code class="language-plaintext highlighter-rouge">Vue</code> 自动转换, 还是能正常运行):<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Vue</span> <span class="nx">warn</span><span class="p">]:</span> <span class="o">&lt;</span><span class="nx">select</span> <span class="nx">multiple</span> <span class="nx">v</span><span class="o">-</span><span class="nx">model</span><span class="o">=</span><span class="dl">"</span><span class="s2">selectM</span><span class="dl">"</span><span class="o">&gt;</span> <span class="nx">expects</span> <span class="nx">an</span> <span class="nb">Array</span> <span class="nx">value</span> <span class="k">for</span> <span class="nx">its</span> <span class="nx">binding</span><span class="p">,</span> <span class="nx">but</span> <span class="nx">got</span> <span class="nb">String</span>
</code></pre></div></div><p>注意, 以上所有类型的 <code class="language-plaintext highlighter-rouge">v-model</code> 和 <code class="language-plaintext highlighter-rouge">value</code> 绑定时, 而 <code class="language-plaintext highlighter-rouge">value</code> 属性又动态 (<code class="language-plaintext highlighter-rouge">:value="xxx"</code>)绑定了 <code class="language-plaintext highlighter-rouge">data</code> 上的其他(<code class="language-plaintext highlighter-rouge">xxx</code>)属性, 则 <code class="language-plaintext highlighter-rouge">v-model</code> 对应的属性和 <code class="language-plaintext highlighter-rouge">:value</code> 对应的属性是同一个(严格相等).<h2 id="组件">组件</h2><p>首先需要区分的是, 什么是 <code class="language-plaintext highlighter-rouge">DOM</code> 模板, 什么是字符串模板.<p><code class="language-plaintext highlighter-rouge">HTML</code> 模板指的是普通的 <code class="language-plaintext highlighter-rouge">html</code> 中的元素, 这些元素会通过 <code class="language-plaintext highlighter-rouge">Vue</code> 实例的 <code class="language-plaintext highlighter-rouge">el</code> 选项进行绑定: 字符串模板部分:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">div</span> <span class="nx">id</span><span class="o">=</span><span class="dl">"</span><span class="s2">tpl</span><span class="dl">"</span><span class="o">&gt;</span>  <span class="nx">实例挂载元素</span>
  <span class="nx">html</span> <span class="nx">自有组件</span><span class="p">:</span>
  <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;&lt;</span><span class="sr">/li</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/ul</span><span class="err">&gt;
</span>  <span class="nx">自定义组件</span><span class="p">:</span>
  <span class="o">&lt;</span><span class="nx">my</span><span class="o">-</span><span class="nx">component</span><span class="o">&gt;&lt;</span><span class="sr">/my-component</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span></code></pre></div></div><p>字符串模板指的是:<p>1.<code class="language-plaintext highlighter-rouge">js</code> 中通过 <code class="language-plaintext highlighter-rouge">template</code> 注册的模板如:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="dl">'</span><span class="s1">my-component</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">template</span><span class="p">:</span> <span class="dl">'</span><span class="s1">&lt;span&gt;&lt;/span&gt;</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">data</span><span class="p">(){</span>
    <span class="na">message</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello, xheldon</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div><p>或者:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Child</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">template</span><span class="p">:</span> <span class="dl">'</span><span class="s1">&lt;div&gt;</span><span class="dl">'</span><span class="nx">hello</span><span class="p">,</span> <span class="nx">xheldon</span><span class="dl">'</span><span class="s1">&lt;/div&gt;</span><span class="dl">'</span>
<span class="p">}</span>
<span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
  <span class="na">components</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">'</span><span class="s1">my-component</span><span class="dl">'</span><span class="p">:</span> <span class="nx">Child</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div><p>2.通过<code class="language-plaintext highlighter-rouge">&lt;script type="text/x-tempalge"&gt;&lt;/script&gt;</code>注册的模板(和 <code class="language-plaintext highlighter-rouge">Handlebar</code> 一样)<p>3.<code class="language-plaintext highlighter-rouge">.vue</code> 组件中的 <code class="language-plaintext highlighter-rouge">&lt;template&gt;</code> 标签内的内容.<p>因为 <code class="language-plaintext highlighter-rouge">Vue</code> 是在浏览器解析完毕之后才开始解析 <code class="language-plaintext highlighter-rouge">DOM</code> 模板的, 因此 <code class="language-plaintext highlighter-rouge">DOM</code> 模板在一些需要特定子元素的标签上不能使用组件. 如 <code class="language-plaintext highlighter-rouge">select</code> 标签下的子元素必须为 <code class="language-plaintext highlighter-rouge">option</code>, 因此用自定义标签 <code class="language-plaintext highlighter-rouge">com-option</code> 则不会识别, 因此可以增加一个 <code class="language-plaintext highlighter-rouge">is="component-name"</code> 属性, 表明该标签使用的模板名字即可.<h2 id="字面量语法-vs-动态语法">字面量语法 VS 动态语法</h2><p>这里需要注意个问题, 即在原生 <code class="language-plaintext highlighter-rouge">js</code> 中, 对象的属性是可以为数字的, 只是其会被当成是字符串(仅限 <code class="language-plaintext highlighter-rouge">ES5</code>, <code class="language-plaintext highlighter-rouge">ES6</code> 中对象属性可以为任意值, 不过和之后要说的不冲突). 但是在 <code class="language-plaintext highlighter-rouge">Vue</code> 中, <code class="language-plaintext highlighter-rouge">data</code> 属性上不能使用数字作为属性, 如果是字面量语法, 传递数字会被先 <code class="language-plaintext highlighter-rouge">toString</code> 处理, 而如果是动态语法, 则会直接当做是数字处理, 不会寻找 <code class="language-plaintext highlighter-rouge">data</code> 上绑定的属性值:<p>子组件模板:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div&gt;</span>{{dynamic}}<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;button</span> <span class="err">@</span><span class="na">click=</span><span class="s">"alertProp"</span><span class="nt">&gt;</span> 点我看上面 props 传参的类型<span class="nt">&lt;/button&gt;</span>
</code></pre></div></div><p>子组件逻辑:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">props</span><span class="p">:[</span><span class="dl">'</span><span class="s1">dynamic</span><span class="dl">'</span><span class="p">],</span>
<span class="nx">methods</span><span class="p">:{</span>
  <span class="nx">alertProp</span><span class="p">(){</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="k">this</span><span class="p">.</span><span class="nx">dynamic</span><span class="p">)</span><span class="c1">//上面说过了, props 属性也是绑定到 Vue 实例上的, 因此可以直接使用 this</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>父组件-字面量语法:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;com-child</span> <span class="na">dynamic=</span><span class="s">"11"</span><span class="nt">&gt;&lt;/com-todolist&gt;</span>
</code></pre></div></div><p>父组件-动态语法:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;com-child</span> <span class="na">:dynamic=</span><span class="s">"11"</span><span class="nt">&gt;&lt;/com-todolist&gt;</span>
</code></pre></div></div><p>以上两种语法下父组件逻辑均为:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span><span class="p">(){</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="mi">11</span><span class="p">:</span><span class="dl">'</span><span class="s1">属性-动态语法</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>结果是, 当使用父组件字面量语法毫无疑问点击 <code class="language-plaintext highlighter-rouge">button</code> 的时候传递给子组件的是 <code class="language-plaintext highlighter-rouge">1</code>, 而且文档也说了, 是字符串的 <code class="language-plaintext highlighter-rouge">1</code>, 因此 <code class="language-plaintext highlighter-rouge">alert</code> 出来的是 <code class="language-plaintext highlighter-rouge">string</code>; 而当父组件动态语法使用 <code class="language-plaintext highlighter-rouge">v-bind</code> 绑定了父组件 <code class="language-plaintext highlighter-rouge">data</code> 的 <code class="language-plaintext highlighter-rouge">1</code> 属性, 但是子组件并没有接收到 <code class="language-plaintext highlighter-rouge">1</code> 属性对应的 <code class="language-plaintext highlighter-rouge">属性-动态语法</code> 这个值, 而还是 <code class="language-plaintext highlighter-rouge">1</code> 这个值, 因此点击 <code class="language-plaintext highlighter-rouge">button</code> 时候 <code class="language-plaintext highlighter-rouge">alert</code> 出来的是 <code class="language-plaintext highlighter-rouge">number</code>.<p>结论: 最好不要使用数字作为 <code class="language-plaintext highlighter-rouge">data</code> 对象的属性.<p>注意: 如果传递给子组件属性的是一个数组或者对象, 在子组件中修改这个属性值, 则会反映到父组件上——这通常是不应该的, 因为俗话说得好: <code class="language-plaintext highlighter-rouge">props down, events up</code>(举例略), 最佳实践应该是使用父组件传递过来的引用类型的深拷贝——当然如果你就是需要子组件影响父组件的状态, 那我祝你好运.<p><code class="language-plaintext highlighter-rouge">events up</code> 的时候, 如果子组件 <code class="language-plaintext highlighter-rouge">$emit</code> 的时候传递了除了事件名之外的其他参数, 则这些参数会被传递给父组件的事件监听函数:<p>子组件模板:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="p">@</span><span class="nd">input</span><span class="o">=</span><span class="dl">"</span><span class="s2">someEventHandlerForOriginalEventLikeClickOrInput($event)</span><span class="dl">"</span><span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;&lt;</span><span class="sr">/span</span><span class="err">&gt;
</span></code></pre></div></div><p>子组件逻辑:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">props</span><span class="p">:[</span><span class="dl">'</span><span class="s1">data</span><span class="dl">'</span><span class="p">],</span>
<span class="nx">methods</span><span class="p">:{</span>
  <span class="nx">someEventHandlerForOriginalEventLikeClickOrInput</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">eventPasstoParent</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="dl">'</span><span class="s1">someOtherArgus</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>父级模板:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;com-todolist</span> <span class="na">:data=</span><span class="s">"someParentData"</span> <span class="err">@</span><span class="na">eventPasstoParent=</span><span class="s">"someParentEventHandler"</span><span class="nt">&gt;&lt;/com-todolist&gt;</span>
</code></pre></div></div><p>父级逻辑:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">someParentData</span><span class="p">:</span> <span class="dl">''</span>
<span class="nx">methods</span><span class="p">:{</span>
  <span class="nx">someParentEventHandler</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">someParentData</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arguments</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="异步更新队列">异步更新队列</h2><p>有了 <code class="language-plaintext highlighter-rouge">Vue</code>, 就不再需要 <code class="language-plaintext highlighter-rouge">jQuery</code> 了, 框架的最大好处是避免了我们对相同操作的写出重复的代码. 双向数据绑定可以帮我们解决很多 <code class="language-plaintext highlighter-rouge">DOM</code> 操作问题, 但是有些情况下 <code class="language-plaintext highlighter-rouge">jQuery</code> 却更有优势, 比如操作 <code class="language-plaintext highlighter-rouge">DOM</code> 的时候, <code class="language-plaintext highlighter-rouge">jQuery</code> 会接收一个函数作为回调函数, 动画执行完成的时候触发. 而我们使用的双向数据绑定, 设置完数据之后, 如何知道 <code class="language-plaintext highlighter-rouge">DOM</code> 已经更新了呢? 答案和 <code class="language-plaintext highlighter-rouge">jQuery</code> 一样, 就是异步更新队列.<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">vm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
  <span class="na">el</span><span class="p">:</span> <span class="dl">'</span><span class="s1">#example</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">data</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">message</span><span class="p">:</span> <span class="dl">'</span><span class="s1">123</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">})</span>
<span class="nx">vm</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">new message</span><span class="dl">'</span> <span class="c1">// 更改数据</span>
<span class="nx">vm</span><span class="p">.</span><span class="nx">$el</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">new message</span><span class="dl">'</span> <span class="c1">// false</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">vm</span><span class="p">.</span><span class="nx">$el</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">new message</span><span class="dl">'</span> <span class="c1">// true</span>
<span class="p">})</span>
</code></pre></div></div><p>这么写我个人是不推荐的, 因为我认为最好的逻辑是写到实例的属性/方法里面, 而不是写到实例的外面, 还好 <code class="language-plaintext highlighter-rouge">Vue</code> 给我们提供了实现方式:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="dl">'</span><span class="s1">example</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">template</span><span class="p">:</span> <span class="dl">'</span><span class="s1">&lt;span&gt;&lt;/span&gt;</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">data</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">message</span><span class="p">:</span> <span class="dl">'</span><span class="s1">not updated</span><span class="dl">'</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="na">methods</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">updateMessage</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">updated</span><span class="dl">'</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">$el</span><span class="p">.</span><span class="nx">textContent</span><span class="p">)</span> <span class="c1">// =&gt; '没有更新'</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$nextTick</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">$el</span><span class="p">.</span><span class="nx">textContent</span><span class="p">)</span> <span class="c1">// =&gt; '更新完成'</span>
      <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div><h2 id="动画">动画</h2><p>动画没什么好说的, 主要是 <code class="language-plaintext highlighter-rouge">JavaScript</code> 钩子函数中的两个钩子需要说下, 一个是 <code class="language-plaintext highlighter-rouge">enterCanceled</code> 和 <code class="language-plaintext highlighter-rouge">leaveCancelled</code>. <code class="language-plaintext highlighter-rouge">enterCancelled</code> 在 <code class="language-plaintext highlighter-rouge">v-if</code> 和 <code class="language-plaintext highlighter-rouge">v-show</code> 中使用, 均可能触发, 而触发时机, 是触发 <code class="language-plaintext highlighter-rouge">enter</code> 的事件之后, 在动画还没有执行完的过程中, 又需要执行其他动画的时候. 而 <code class="language-plaintext highlighter-rouge">leaveCancelled</code> 只用于 <code class="language-plaintext highlighter-rouge">v-show</code> 中, 在 <code class="language-plaintext highlighter-rouge">v-if</code> 中使用时无效的, 永远不会被触发, 其触发时机是在离开动画(即 <code class="language-plaintext highlighter-rouge">xxx-leave-active</code> 动画)播放未完成的时候, 又执行了其他动画的时候触发.<p>测试代码:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">"button"</span> <span class="err">@</span><span class="na">click=</span><span class="s">"show=!show"</span><span class="nt">&gt;</span>点击我切换状态<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;transition</span> <span class="na">name=</span><span class="s">"go"</span>
  <span class="err">@</span><span class="na">before-enter=</span><span class="s">"beforeEnter"</span>
  <span class="err">@</span><span class="na">enter=</span><span class="s">"enter"</span>
  <span class="err">@</span><span class="na">after-enter=</span><span class="s">"afterEnter"</span>
  <span class="err">@</span><span class="na">enter-cancelled=</span><span class="s">"enterCancelled"</span>
  <span class="err">@</span><span class="na">before-leave=</span><span class="s">"beforeLeave"</span>
  <span class="err">@</span><span class="na">leave=</span><span class="s">"leave"</span>
  <span class="err">@</span><span class="na">after-leave=</span><span class="s">"afterLeave"</span>
  <span class="err">@</span><span class="na">leave-cancelled=</span><span class="s">"leaveCancelled"</span>
<span class="nt">&gt;</span>
此处使用 v-show, 修改成 v-if 的时候发现, leave-cancelled 不会触发.
<span class="nt">&lt;p</span> <span class="na">v-show=</span><span class="s">"show"</span><span class="nt">&gt;</span>
  点击展示我, 再点击一下隐藏我.
<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/transition&gt;</span>
</code></pre></div></div><p>逻辑:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span><span class="p">(){</span>
  <span class="k">return</span><span class="p">{</span>
    <span class="na">show</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">}</span>
<span class="p">},</span>
<span class="nx">methods</span><span class="p">:</span> <span class="p">{</span>
  <span class="nx">beforeEnter</span><span class="p">(){</span><span class="nx">alert</span><span class="p">(</span><span class="mi">1</span><span class="p">);},</span>
  <span class="nx">enter</span><span class="p">(){</span> <span class="nx">alert</span><span class="p">(</span><span class="mi">2</span><span class="p">);},</span>
  <span class="nx">afterEnter</span><span class="p">(){</span> <span class="nx">alert</span><span class="p">(</span><span class="mi">3</span><span class="p">);},</span>
  <span class="nx">enterCancelled</span><span class="p">(){</span> <span class="nx">alert</span><span class="p">(</span><span class="mi">4</span><span class="p">);},</span>
  <span class="nx">beforeLeave</span><span class="p">(){</span> <span class="nx">alert</span><span class="p">(</span><span class="mi">5</span><span class="p">);},</span>
  <span class="nx">leave</span><span class="p">(){</span><span class="nx">alert</span><span class="p">(</span><span class="mi">6</span><span class="p">);},</span>
  <span class="nx">afterLeave</span><span class="p">(){</span> <span class="nx">alert</span><span class="p">(</span><span class="mi">7</span><span class="p">);},</span>
  <span class="nx">leaveCancelled</span><span class="p">(){</span> <span class="nx">alert</span><span class="p">(</span><span class="mi">8</span><span class="p">);}</span>
<span class="p">},</span>
</code></pre></div></div><p>样式:<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.button-animate</span> <span class="nt">button</span><span class="p">{</span>
  <span class="nl">margin-left</span><span class="p">:</span><span class="m">20px</span><span class="p">;</span>
  <span class="nl">margin-top</span><span class="p">:</span> <span class="m">40px</span><span class="p">;</span>
  <span class="nl">transition</span><span class="p">:</span> <span class="n">all</span> <span class="m">1s</span> <span class="n">ease</span><span class="p">;</span>
  <span class="nl">position</span><span class="p">:</span> <span class="nb">absolute</span><span class="p">;</span>
<span class="p">}</span>
<span class="nc">.go-enter-active</span> <span class="p">{</span>
  <span class="nl">transition</span><span class="p">:</span> <span class="n">all</span> <span class="m">5s</span> <span class="n">ease</span><span class="p">;</span>
<span class="p">}</span>
<span class="nc">.go-leave-active</span> <span class="p">{</span>
  <span class="nl">transition</span><span class="p">:</span> <span class="n">all</span> <span class="m">5s</span> <span class="n">cubic-bezier</span><span class="p">(</span><span class="m">1.0</span><span class="p">,</span> <span class="m">0.5</span><span class="p">,</span> <span class="m">0.8</span><span class="p">,</span> <span class="m">1.0</span><span class="p">);</span>
<span class="p">}</span>
<span class="nc">.go-enter</span><span class="o">,</span> <span class="nc">.go-leave-active</span> <span class="p">{</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">10px</span><span class="p">);</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>钩子们的参数除了 <code class="language-plaintext highlighter-rouge">enter</code> 和 <code class="language-plaintext highlighter-rouge">leave</code> 是 <code class="language-plaintext highlighter-rouge">el</code> 元素本身(原生的 <code class="language-plaintext highlighter-rouge">Element</code> 类型元素), 和 <code class="language-plaintext highlighter-rouge">done</code> 回调函数外, 其他钩子的参数均为 <code class="language-plaintext highlighter-rouge">el</code> 元素本身.<p>元素的过渡, 最好给每个元素加个 <code class="language-plaintext highlighter-rouge">key</code>, 因为之前提到的就地复用策略, 可能在切换的时候直接替换数据, 没有动画效果.<p>在官方文档中完全没有说明的一点是, <code class="language-plaintext highlighter-rouge">Vue transition</code> 的动画类名 <code class="language-plaintext highlighter-rouge">css</code> 的写法是有顺序限制的, <code class="language-plaintext highlighter-rouge">v-enter</code> 和 <code class="language-plaintext highlighter-rouge">v-leave</code> 必须写在 <code class="language-plaintext highlighter-rouge">v-enter-active</code> 和 <code class="language-plaintext highlighter-rouge">v-leave-active</code> 的后面, 否则无效, 比如我想写一个点击按钮的淡入淡出效果, 点击按钮之后会有一个按钮从左向右淡入, 同时当前点击的按钮任从左往右淡出: 逻辑:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">data</span><span class="p">:{</span>
  <span class="nl">isShow</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">},</span>
<span class="nx">methods</span><span class="p">:{</span>
  <span class="nx">animakkey</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">isShow</span> <span class="o">=</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">isShow</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>结构:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"button-animate"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;transition</span> <span class="na">name=</span><span class="s">"go"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">key=</span><span class="s">"a"</span> <span class="na">v-if=</span><span class="s">"isShow"</span> <span class="err">@</span><span class="na">click=</span><span class="s">"animakkey"</span><span class="nt">&gt;</span>on<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">key=</span><span class="s">"b"</span> <span class="na">v-else</span> <span class="err">@</span><span class="na">click=</span><span class="s">"animakkey"</span><span class="nt">&gt;</span>off<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/transition&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div><p>如果你的样式是这样的:<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.button-animate</span> <span class="nt">button</span><span class="p">{</span>
  <span class="nl">margin-left</span><span class="p">:</span><span class="m">20px</span><span class="p">;</span>
  <span class="nl">margin-top</span><span class="p">:</span> <span class="m">40px</span><span class="p">;</span>
  <span class="nl">transition</span><span class="p">:</span> <span class="n">all</span> <span class="m">1s</span> <span class="n">ease</span><span class="p">;</span>
  <span class="nl">position</span><span class="p">:</span> <span class="nb">absolute</span><span class="p">;</span>
<span class="p">}</span>
<span class="nc">.go-enter</span><span class="p">{</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">-25px</span><span class="p">);</span>
<span class="p">}</span>
<span class="nc">.go-leave</span><span class="p">{</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">25px</span><span class="p">);</span>
<span class="p">}</span>
<span class="nc">.go-enter-active</span><span class="p">{</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">0px</span><span class="p">);</span>
<span class="p">}</span>

<span class="nc">.go-leave-active</span><span class="p">{</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">50px</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>会发现动画效果并不如意:<p><img src="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/img/2016/animateBad.gif" alt="animate" title="animate" /><p>而如果把 <code class="language-plaintext highlighter-rouge">enter</code> 放到 <code class="language-plaintext highlighter-rouge">enter-active</code> 的后面:<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.button-animate</span> <span class="nt">button</span><span class="p">{</span>
  <span class="nl">margin-left</span><span class="p">:</span><span class="m">20px</span><span class="p">;</span>
  <span class="nl">margin-top</span><span class="p">:</span> <span class="m">40px</span><span class="p">;</span>
  <span class="nl">transition</span><span class="p">:</span> <span class="n">all</span> <span class="m">1s</span> <span class="n">ease</span><span class="p">;</span>
  <span class="nl">position</span><span class="p">:</span> <span class="nb">absolute</span><span class="p">;</span>
<span class="p">}</span>
<span class="nc">.go-enter-active</span><span class="p">{</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">0px</span><span class="p">);</span>
<span class="p">}</span>
<span class="nc">.go-enter</span><span class="p">{</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">-25px</span><span class="p">);</span>
<span class="p">}</span>
<span class="nc">.go-leave-active</span><span class="p">{</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">50px</span><span class="p">);</span>
<span class="p">}</span>
<span class="nc">.go-leave</span><span class="p">{</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">25px</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>就完美了:<p><img src="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/img/2016/animateGood.gif" alt="animate" title="animate" /><p>在对比了这四个 <code class="language-plaintext highlighter-rouge">css</code> 类名的可能顺序之后, 发现只要 <code class="language-plaintext highlighter-rouge">v-enter</code> 放到 <code class="language-plaintext highlighter-rouge">v-enter-active</code> 的后面就能实现效果, 其他类名随意.<p><code class="language-plaintext highlighter-rouge">transition</code> 标签中不能放其他元素而只能是放需要动画的元素, 如果上述示例结构写成这个样子:<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;transition</span> <span class="na">name=</span><span class="s">"go"</span><span class="nt">&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"button-animate"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;button</span> <span class="na">key=</span><span class="s">"a"</span> <span class="na">v-if=</span><span class="s">"isShow"</span> <span class="err">@</span><span class="na">click=</span><span class="s">"animakkey"</span><span class="nt">&gt;</span>on<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;button</span> <span class="na">key=</span><span class="s">"b"</span> <span class="na">v-else</span> <span class="err">@</span><span class="na">click=</span><span class="s">"animakkey"</span><span class="nt">&gt;</span>off<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/transition&gt;</span>
</code></pre></div></div><p>则不会有任何动画效果, 而如果在正常 <code class="language-plaintext highlighter-rouge">css</code> 类名中使用一些 <code class="language-plaintext highlighter-rouge">css</code> 属性规定了元素的样式, 而在动画类名如 <code class="language-plaintext highlighter-rouge">v-enter</code> 中又使用了相同的属性, 则也不会生效, <a href="https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名">文档</a> 说”他们的优先级高于普通的类名”, 实则不然(也不知道是我理解错误?欢迎指正), 还是上例, 样式中, 设置 <code class="language-plaintext highlighter-rouge">button</code> 的正常 <code class="language-plaintext highlighter-rouge">css</code> 属性:<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.button-animate</span> <span class="nt">button</span><span class="p">{</span>
  <span class="nl">margin-left</span><span class="p">:</span><span class="m">20px</span><span class="p">;</span>
  <span class="nl">margin-top</span><span class="p">:</span> <span class="m">40px</span><span class="p">;</span>
  <span class="nl">transition</span><span class="p">:</span> <span class="n">all</span> <span class="m">1s</span> <span class="n">ease</span><span class="p">;</span>
  <span class="nl">position</span><span class="p">:</span> <span class="nb">absolute</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span><span class="n">translateX</span><span class="p">(</span><span class="m">50px</span><span class="p">);</span>
<span class="p">}</span>
<span class="nc">.go-enter-active</span><span class="p">{</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">0px</span><span class="p">);</span>
<span class="p">}</span>
<span class="nc">.go-enter</span><span class="p">{</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">-25px</span><span class="p">);</span>
<span class="p">}</span>
<span class="nc">.go-leave-active</span><span class="p">{</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">50px</span><span class="p">);</span>
<span class="p">}</span>
<span class="nc">.go-leave</span><span class="p">{</span>
  <span class="nl">opacity</span><span class="p">:</span> <span class="m">1</span><span class="p">;</span>
  <span class="nl">transform</span><span class="p">:</span> <span class="n">translateX</span><span class="p">(</span><span class="m">25px</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>结果:<p><img src="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/img/2016/animateWithout.gif" alt="animate" title="animate" /><p>可以看到, 只有 <code class="language-plaintext highlighter-rouge">opacity</code> 产生了动画, <code class="language-plaintext highlighter-rouge">transform</code> 没有动画!(同学们可以测试下是用 <code class="language-plaintext highlighter-rouge">animate.css</code> 的时候, 使用 <code class="language-plaintext highlighter-rouge">Animate.css</code> 中相同的属性来提前设置元素, 是否还有动画效果, 欢迎提 <code class="language-plaintext highlighter-rouge">issue</code>.)<p><code class="language-plaintext highlighter-rouge">transition-group</code> 和 <code class="language-plaintext highlighter-rouge">transition</code> 有点不太一样, 从外观上说, <code class="language-plaintext highlighter-rouge">transition</code> 本身只是个包裹容器, 不参与任何的页面构成, 但是 <code class="language-plaintext highlighter-rouge">transition-group</code> 却会被 <code class="language-plaintext highlighter-rouge">Vue</code> 替换为一个标签, 默认是 <code class="language-plaintext highlighter-rouge">span</code> 标签, 也可以定制被替换成的标签名.<h2 id="render-函数"><code class="language-plaintext highlighter-rouge">render</code> 函数</h2><p>使用 <code class="language-plaintext highlighter-rouge">render</code> 函数可以代替写模板的作用, 其形参 <code class="language-plaintext highlighter-rouge">createElement</code> 一般被写成 <code class="language-plaintext highlighter-rouge">h</code>, 在组件或者标签内的各种绑定/属性等, 在 <code class="language-plaintext highlighter-rouge">createElement</code> 中都能找到对应的 <code class="language-plaintext highlighter-rouge">JavaScript</code> 写法, 如果找不到, 那就说明可以使用原生的写法, 比如 <code class="language-plaintext highlighter-rouge">.stop</code>, <code class="language-plaintext highlighter-rouge">.prevent</code> 等, 直接使用 <code class="language-plaintext highlighter-rouge">event.stopPropagation()</code> 和 <code class="language-plaintext highlighter-rouge">event.preventDefault()</code> 即可.<h2 id="其他">其他</h2><p>混合(<code class="language-plaintext highlighter-rouge">mixin</code>), 就是指在写正常的组件过程中(也即在组件的生命周期中), 修改或者添加额外的功能.<p>部分<code class="language-plaintext highlighter-rouge">插件</code>就是根据上面的 <code class="language-plaintext highlighter-rouge">mixin</code> 写的, 除此之外的插件还有往 <code class="language-plaintext highlighter-rouge">Vue.prototype</code> 添加方法, 或者通过 <code class="language-plaintext highlighter-rouge">config</code> 添加一些全局的方法或者属性.<p><code class="language-plaintext highlighter-rouge">路由</code>, 可以通过 <code class="language-plaintext highlighter-rouge">component</code> 的 <code class="language-plaintext highlighter-rouge">is</code> 属性来简单实现, 也可以直接写 <code class="language-plaintext highlighter-rouge">render</code> 函数根据不同路径渲染不同模板, 当然更复杂的需要第三方库了.<p><code class="language-plaintext highlighter-rouge">状态管理</code>, 看示例是要加个 <code class="language-plaintext highlighter-rouge">wrap</code> 来记录每个状态改变的过程, 然后官方建议的最佳实践是即使你能直接复制给示例属性, 但是也最好通过函数来修改状态, 因为这让状态变得可追踪.<p><code class="language-plaintext highlighter-rouge">单元测试</code>, 就是正常的单元测试, 没什么好说的.<h2 id="服务端渲染server-side-render">服务端渲染(<code class="language-plaintext highlighter-rouge">Server Side Render</code>)</h2><p>看了下思路, 基本上很简单, 就是首先在 <code class="language-plaintext highlighter-rouge">app.js</code> 中 <code class="language-plaintext highlighter-rouge">exports</code> 一个 <code class="language-plaintext highlighter-rouge">Vue</code> 实例, 然后新建一个页面模板文件 <code class="language-plaintext highlighter-rouge">index.html</code>(引入 <code class="language-plaintext highlighter-rouge">Vue.js</code> 和挂载 <code class="language-plaintext highlighter-rouge">Vue</code> 实例的方法 <code class="language-plaintext highlighter-rouge">$mount</code>, 官网同样也引入了 <code class="language-plaintext highlighter-rouge">app.js</code>, 是否需要待我验证下再说), 含有实例的挂载点(一个带有 <code class="language-plaintext highlighter-rouge">id</code> 属性的非空元素), 然后在服务端 <code class="language-plaintext highlighter-rouge">server.js</code> 都 <code class="language-plaintext highlighter-rouge">require</code> 过来, 用 <code class="language-plaintext highlighter-rouge">vue-server-renderer</code> 这个东西, 把 <code class="language-plaintext highlighter-rouge">app.js</code> 中 <code class="language-plaintext highlighter-rouge">exports</code> 出去的 <code class="language-plaintext highlighter-rouge">Vue</code> 实例渲染下, 再在返回给客户端的时候替换掉挂载点(一个带有 <code class="language-plaintext highlighter-rouge">id</code> 属性的非空元素, 因为 <code class="language-plaintext highlighter-rouge">app.js</code> 中的模板已经存在了)即可.<p>服务端渲染的结果就是, 会在上述的挂载点(一个带有 <code class="language-plaintext highlighter-rouge">id</code> 属性的非空元素)加一个 <code class="language-plaintext highlighter-rouge">server-rendered="true"</code> 的属性(通过右键查看页面源代码查看存在, 说明不是 <code class="language-plaintext highlighter-rouge">js</code> 动态添加的).<p>服务端也支持流式渲染, 首先需要把 <code class="language-plaintext highlighter-rouge">html</code> 以挂载点(一个带有 <code class="language-plaintext highlighter-rouge">id</code> 属性的非空元素,如 <code class="language-plaintext highlighter-rouge">&lt;div id="app"&gt;&lt;/div&gt;</code>)为分割点, <code class="language-plaintext highlighter-rouge">split</code> 一下, 分为 <code class="language-plaintext highlighter-rouge">ab</code> 两个部分, 而刚刚使用的 <code class="language-plaintext highlighter-rouge">vue-server-renderer</code> 的是把 <code class="language-plaintext highlighter-rouge">app.js</code> <code class="language-plaintext highlighter-rouge">renderToString</code> 了, 而为了支持流式渲染, 需要换个方法叫 <code class="language-plaintext highlighter-rouge">renderToStream</code>, 然后监听 <code class="language-plaintext highlighter-rouge">data</code> 事件, 附加到, <code class="language-plaintext highlighter-rouge">html</code> 的 <code class="language-plaintext highlighter-rouge">a</code> 部分的后面, <code class="language-plaintext highlighter-rouge">end</code> 事件之后, 再拼接上 <code class="language-plaintext highlighter-rouge">html</code> 的 <code class="language-plaintext highlighter-rouge">b</code> 部分, 最后再一并 <code class="language-plaintext highlighter-rouge">res.send</code> 出去.<h2 id="后记">后记</h2><p>坐标帝都, <code class="language-plaintext highlighter-rouge">ping</code> <code class="language-plaintext highlighter-rouge">cn.vuejs.org</code>:<p><img src="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/img/2016/ping1.png" alt="ping" title="ping" /><p><code class="language-plaintext highlighter-rouge">ping</code> 我司<code class="language-plaintext highlighter-rouge">FQ</code> <code class="language-plaintext highlighter-rouge">VPS</code>:<p><img src="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/img/2016/ping2.png" alt="ping" title="ping" /><p><code class="language-plaintext highlighter-rouge">dig</code> 一下:<p><img src="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/img/2016/dig1.png" alt="dig" title="dig" /><p>可以看到使用的是 <code class="language-plaintext highlighter-rouge">cloudflare</code> 的服务, 国际网站不好做呀, 呵呵.</article><div class="page-footer"><hr /> 转载请<a href="/tech/vue-learning-summary.html">注明出处</a>&nbsp;&nbsp;打赏请<a href="/donate/" target="_blank">移步这里</a> <br><br> <span class="EOF">- EOF -</span> <br><br><div class="panel-body"><h4>相同分类:</h4><ul><li class="relatedPost"> <a href="/tech/Collaborative-Editing-in-ProseMirror.html">[译]ProseMirror 中的协同编辑实现</a> (分类: <a href="/category/Framework">Framework</a>, <a href="/category/ProseMirror">ProseMirror</a>)<li class="relatedPost"> <a href="/tech/vue-reactive.html">Vue 响应式原理及实现</a> (分类: <a href="/category/Framework">Framework</a>)<li class="relatedPost"> <a href="/tech/three-ways-to-make-a-vue-SPA-use-router.html">Vue 实现路由的三种方式</a> (分类: <a href="/category/Framework">Framework</a>)<li class="relatedPost"> <a href="/tech/webpack-details-one.html">Webpack 异步按需加载</a> (分类: <a href="/category/Framework">Framework</a>)<li class="relatedPost"> <a href="/tech/vue-simple-use.html">Vue + Webpack 组件式开发(练习环境)初体验</a> (分类: <a href="/category/Framework">Framework</a>)</ul></div><div class="page-navigation"> <a class="prev" href="/tech/three-ways-to-make-a-vue-SPA-use-router.html">&laquo; Vue 实现路由的三种方式</a> <a class="next" href="/tech/github-pages-config.html">关于本博客域名优化配置的几点说明 &raquo;</a></div><div id="gitalk-container"></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script type="text/javascript"> window.addEventListener('load', function(){ var gitalk = new Gitalk({ clientID: 'd2b353a60fa1233163fc', clientSecret: '8091d57674976bcd60fc05261bf93c00da7e5ff4', repo: 'x_blog', owner: 'Xheldon', admin: ['Xheldon'], id: "vue-learning-summary" }); gitalk.render('gitalk-container'); }); </script></main><footer> &copy; 2021 - Xheldon - Theme Powered By Xheldon <span class="footer-social"> <a href="https://twitter.com/_Xheldon" target="_blank"><i class="fab fa-twitter"></i></a> <a href="https://t.me/xheldon_saloon" target="_blank"><i class="fab fa-telegram"></i></a> <a href="https://www.zhihu.com/people/xheldon/pins" target="_blank"><i class="fa" style="font-size: 16px;line-height:2;">知乎</i></a> </span></footer></div><script type="text/javascript"> !function () { function e(t) { var n = {}; if (1 == t.nodeType) { if (t.attributes.length > 0) { n["@attributes"] = {}; for (var i = 0; i < t.attributes.length; i++) { var s = t.attributes.item(i); n["@attributes"][s.nodeName] = s.nodeValue } } } else 3 == t.nodeType && (n = t.nodeValue); var a = [].slice.call(t.childNodes).filter(function (e) { return 3 === e.nodeType }); if (t.hasChildNodes() && t.childNodes.length === a.length) n = [].slice.call(t.childNodes).reduce(function (e, t) { return e + t.nodeValue }, ""); else if (t.hasChildNodes()) for (var r = 0; r < t.childNodes.length; r++) { var o = t.childNodes.item(r), d = o.nodeName; if ("undefined" == typeof n[d]) n[d] = e(o); else { if ("undefined" == typeof n[d].push) { var c = n[d]; n[d] = [], n[d].push(c) } n[d].push(e(o)) } } return n } function t(t) { var n = e(t); return n.channel.item } var n, i = document.querySelector("#js-search"), s = document.querySelector("#js-search__input"), a = document.querySelector("#js-search__results"), r = "", o = [], d = new XMLHttpRequest; d.open("GET", "/sitemap.xml"), d.onreadystatechange = function () { if (4 == d.readyState && (200 == d.status || 304 == d.status)) { var e = (new DOMParser).parseFromString(d.responseText, "text/xml"); e = e.children[0], o = t(e) } }, d.send(), window.toggleSearch = function () { _gaq.push(["_trackEvent", "supersearch", i.classList.contains("is-active")]), i.classList.toggle("is-active"), i.classList.contains("is-active") ? s.value = "" : a.classList.add("is-hidden"), setTimeout(function () { s.focus() }, 210) }, window.addEventListener("keyup", function (e) { 27 === e.which && toggleSearch() }), window.addEventListener("keypress", function (e) { 47 !== e.which || i.classList.contains("is-active") || toggleSearch() }), s.addEventListener("input", function () { var e, t; if (r = (s.value + "").toLowerCase(), !r || r.length < 3) return n = "", void a.classList.add("is-hidden"); a.style.offsetWidth; var i; i = void 0 === o.title ? o.filter(function (e) { return -1 !== (e.title + "").toLowerCase().indexOf(r) || -1 !== (e.description + "").toLowerCase().indexOf(r) ? !0 : void 0 }) : [o], i.length || a.classList.add("is-hidden"), e = i.reduce(function (e, t) { return t.title + e }, ""), i.length && e !== n && (a.classList.remove("is-hidden"), a.innerHTML = i.map(function (e) { return t = new Date(e.pubDate), '<li><a href="' + e.link + '">' + e.title + "</a>" }).join("")), n = e }) }(); </script><link href="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/css/font-awesome.min.css" rel="stylesheet" crossorigin="anonymous"> <script> (function (i, s, o, g, r, a, m) { i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments) }, i[r].l = 1 * new Date(); a = s.createElement(o), m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m) })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga'); ga('create', 'UA-79359216-1', 'auto'); ga('send', 'pageview'); </script> <script> document.addEventListener('DOMContentLoaded',function(){ try { Array.prototype.slice.call(document.querySelectorAll('a')).forEach(function(a){ if (!a.getAttribute('target')) { let href = a.getAttribute('href'); let attrs = Object.keys(a.dataset); if (href && href.indexOf('/') && href.indexOf('#')) { a.setAttribute('target', '_blank'); } else { a.setAttribute('target', '_self'); } /* 默认情况下外链在新窗口打开, 本地链接在当前窗口打开 kramdown 可以对 url 设置特殊属性 data-open, 因此用此特性来排除需要在新窗口打开的本地链接 */ if (attrs.length) { attrs.forEach(function(attr){ switch (attr) { case 'open': a.setAttribute('target', '_blank'); break; default: break; } }); } } }); } catch (e) { console.log('新窗口打开链接失败:', e); } /*try { let toc = document.getElementById('post-toc'); if (toc) { function setPosition() { let offset = toc.parentElement.getBoundingClientRect().y; if (offset <= 50) { toc.style.position = 'fixed'; toc.style.top = '50px'; } else { toc.style.position = 'absolute'; toc.style.top = '0'; } } setPosition(); window.addEventListener('scroll', setPosition); } } catch(e) { console.log('toc滚动失败'); }*/ }); </script>
