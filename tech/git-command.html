<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0,user-scalable=no"/><link rel="shortcut icon" href="/favicon.ico" /><title>git 常用命令总结 - Xheldon</title><meta name="author" content="Xheldon" /><meta name="description" content="git 常用命令总结" /><meta name="keywords" content="git 常用命令总结, Xheldon, VCS" /><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"><meta content="" property="fb:app_id"><meta content="Xheldon" property="og:site_name"><meta content="git 常用命令总结" property="og:title"><meta content="article" property="og:type"><meta content="会点前端，在学 Node、Electron、ProseMirror" property="og:description"><meta content="https://xheldon.com/tech/git-command.html" property="og:url"><meta content="2016-04-21T05:34:23+00:00" property="article:published_time"><meta content="https://xheldon.com/about/" property="article:author"><meta content="/resource/img/logo_min.png" property="og:image"><meta content="VCS" property="article:section"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@"><meta name="twitter:title" content="git 常用命令总结"><meta name="twitter:url" content="https://xheldon.com/tech/git-command.html"><meta name="twitter:description" content="会点前端，在学 Node、Electron、ProseMirror"><style type="text/css"> /* Project Elements */ .project-outer { display: inline-block; min-width: 30%; max-width: 45%; vertical-align: top; margin: 0 1.6%; overflow: hidden; } .project-img img { width: 100%; } h3.project-headlines { margin: 5px 0; font-size: 20px; } span.tags { font-size: 10px; border-bottom: 1px #888 dotted; margin: 0 5px; } span.tags:first-child { margin-left: 0; } span.tags:last-child { margin-right: 0; } .project-footer { clear: both; display: inline-block; width: 100%; } .project-footer .project-link { display: inline-block; position: relative; float: left; text-decoration: none; } .project-footer .project-timeline { display: inline-block; position: relative; float: right; font-size: 13px; font-style: italic; } .project-inner>a { display: block; } .project-img { width: 100%; height: 200px; display: block; background-size: contain; background-repeat: no-repeat; background-position: center center; } /** Project Tag Filters **/ .tag-group { margin: 0 0 25px 0; } span.tag-cloud { margin: 0 2px; cursor: pointer; font-size: 75%; padding: .2em .6em .3em; font-weight: 700; display: inline; } .tag-cloud.active { background: #ccc; } .project-item.not-show { display: none; } a.project-detail:hover { text-decoration: none; } a.project-detail:hover h3 { color: #428bca; }</style><link rel="stylesheet" href="/resource/css/main.css?t=20190911161844"><body><div class="container" id="container-post"><header id="header-post"> <a href="/"><img class="profile-avatar" src="/resource/img/logo_min.png" height="75px" width="75px" /></a><nav class="navlinks"><li><a class="about" href="https://42.xheldon.com/about/">我</a><li><a class="about" href="/book-list/">书单</a><li><a class="about" href="/projects/">项目</a><li><a class="about" href="/donate/">赞赏</a><li><a class="about" href="/feed.xml">订阅</a></nav><div class="search" id="js-search"> <input type="text" placeholder="搜索一下" class="search__input form-control" id="js-search__input"><ul class="search__results" id="js-search__results"></ul></div></header><main class="main-layout" id="page-post"><aside id="toc"><ul id="my_toc"><li><a href="#前言">前言</a><li><a href="#正文">正文</a><li><a href="#更新">更新</a></ul></aside><article class="post"><section class="post-header"><h1 class="post-title">git 常用命令总结</h1><div> <time class="time">2016年04月21日</time> <span class="categories"> &raquo; <a href="/category/VCS">VCS</a> </span></div></section><div class="time-tips">注意：离本文创建时间已经过去了 <code>1903</code> 天, 请注意时效性</div><h2 id="前言">前言</h2><p>经常使用git，但是一直没时间写，现在终于有时间了，所以总结一下常用命令。<h2 id="正文">正文</h2><p>新建一个分支并切换到这个分支：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">checkout</span> <span class="o">-</span><span class="nx">b</span> <span class="nx">branch_name</span>
</code></pre></div></div><p>切换分支:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">checkout</span> <span class="nx">branch_name</span>
</code></pre></div></div><p>删除一个分支(需要先<code class="language-plaintext highlighter-rouge">checkout</code>到另一个分支):<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">branch</span> <span class="o">-</span><span class="nx">d</span> <span class="nx">branch_name</span>
</code></pre></div></div><p>注意，如果你在本地新建一个分支，而没有<code class="language-plaintext highlighter-rouge">git push</code>的话，执行下列命令删除一个分支会提示你<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">error</span><span class="p">:</span> <span class="nx">The</span> <span class="nx">branch</span> <span class="dl">'</span><span class="s1">test</span><span class="dl">'</span> <span class="nx">is</span> <span class="nx">not</span> <span class="nx">fully</span> <span class="nx">merged</span><span class="p">.</span>
<span class="nx">If</span> <span class="nx">you</span> <span class="nx">are</span> <span class="nx">sure</span> <span class="nx">you</span> <span class="nx">want</span> <span class="nx">to</span> <span class="k">delete</span> <span class="nx">it</span><span class="p">,</span> <span class="nx">run</span> <span class="dl">'</span><span class="s1">git branch -D test</span><span class="dl">'</span><span class="p">.</span>
</code></pre></div></div><p>确定不要的话，按说明强制删除即可。<p>提交文件的流程是:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">add</span> <span class="o">==&gt;</span> <span class="nx">git</span> <span class="nx">commit</span> <span class="o">==&gt;</span> <span class="nx">git</span> <span class="nx">push</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">git add</code>常用的有三个参数:<ol><li><code class="language-plaintext highlighter-rouge">git add -A</code> 所有变动记录都增加到暂存区，不管是新增还是删除还是修改。<li><code class="language-plaintext highlighter-rouge">git add .</code> 文件的增加记录，修改添加到暂存区，不包括删除的文件。<li><code class="language-plaintext highlighter-rouge">git add -u</code> 文件的删除和修改记录添加到暂存区，不包括新增的文件。</ol><p>人生没有后悔药，但是<code class="language-plaintext highlighter-rouge">git</code>有，如果不小心提交了错误的文件或者提交信息写错了，可以根据情况执行以下命令。<p>首先<code class="language-plaintext highlighter-rouge">git status</code> 查看版本状态，(我用<code class="language-plaintext highlighter-rouge">zsh</code>)红色文件表示未<code class="language-plaintext highlighter-rouge">git add</code>到暂存区，绿色文件表示已经<code class="language-plaintext highlighter-rouge">git add</code>到缓存区，等待<code class="language-plaintext highlighter-rouge">git commit</code>。<p>这个时候如果不想<code class="language-plaintext highlighter-rouge">git add</code>到缓存区的话，那就<code class="language-plaintext highlighter-rouge">git reset HEAD</code>全部将文件重新变为未<code class="language-plaintext highlighter-rouge">git add</code>的原始状态，如果只是不想<code class="language-plaintext highlighter-rouge">git add</code>某一个文件到缓存区的话, 需要指定文件名:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">reset</span> <span class="nx">HEAD</span> <span class="nx">filename</span>
</code></pre></div></div><p>有时候不但不想把修改过的文件<code class="language-plaintext highlighter-rouge">git add</code>到缓存区，而且想把这个文件所做的修改都忽略掉，也即回复到未修改的状态，那重新检出即可:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">checkout</span> <span class="o">--</span> <span class="nx">filename</span>
</code></pre></div></div><p>注意这里没有拼写错误,<code class="language-plaintext highlighter-rouge">checkout</code>和<code class="language-plaintext highlighter-rouge">filename</code>之间有左右存在一个空格的短横线。<p><code class="language-plaintext highlighter-rouge">git add</code>之后就是<code class="language-plaintext highlighter-rouge">git commit</code>，可以跟一个参数<code class="language-plaintext highlighter-rouge">-m</code>来写下提交说明，这是个好习惯，而且是被强制的，如果没有<code class="language-plaintext highlighter-rouge">-m</code>参数，则会进入一个<code class="language-plaintext highlighter-rouge">vim</code>编辑状态，提示你加上信息:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">commit</span> <span class="o">-</span><span class="nx">m</span> <span class="dl">'</span><span class="s1">这是一个提交说明</span><span class="dl">'</span>
</code></pre></div></div><p>这个时候发现提交说明写错了，不想<code class="language-plaintext highlighter-rouge">commit</code>了（此时<code class="language-plaintext highlighter-rouge">HEAD</code>已经变了），两个方法：<p>一个是移除<code class="language-plaintext highlighter-rouge">commit</code>：（因为这个还没有<code class="language-plaintext highlighter-rouge">push</code>，只是<code class="language-plaintext highlighter-rouge">commit</code>到本地仓库）<p>首先<code class="language-plaintext highlighter-rouge">git log</code>，记下你误<code class="language-plaintext highlighter-rouge">commit</code>之前的一个<code class="language-plaintext highlighter-rouge">commit id</code>，是一个<code class="language-plaintext highlighter-rouge">hash(SHA)</code>，如：<code class="language-plaintext highlighter-rouge">73cf3bfc3419a85e959d7ecfcb917d9cdc24b3c9</code>或者直接是最近的一次<code class="language-plaintext highlighter-rouge">push</code>的<code class="language-plaintext highlighter-rouge">HEAD</code>也行：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">reset</span> <span class="mi">73</span><span class="nx">cf3bfc3419a85e959d7ecfcb917d9cdc24b3c9</span>
</code></pre></div></div><p>（这个时候不能像<code class="language-plaintext highlighter-rouge">git add</code>的时候使用<code class="language-plaintext highlighter-rouge">git reset HEAD</code>了因为<code class="language-plaintext highlighter-rouge">git commit</code>之后<code class="language-plaintext highlighter-rouge">HEAD</code>已经变了(即已经可以通过<code class="language-plaintext highlighter-rouge">git log</code>查看提交记录了)）<p>这里插一句<code class="language-plaintext highlighter-rouge">git reset</code>命令的三个参数:<code class="language-plaintext highlighter-rouge">--mixed</code>,<code class="language-plaintext highlighter-rouge">--soft</code>,<code class="language-plaintext highlighter-rouge">--hard</code>:<p>网上的教程一大堆，又是画图说明又是引用官方分支说明的，麻烦，我说的简单点。<blockquote><p>简单的，举例子的方式简单点。 —Xheldon</blockquote><p><code class="language-plaintext highlighter-rouge">git reset</code>默认是<code class="language-plaintext highlighter-rouge">mixed</code>参数，即执行<code class="language-plaintext highlighter-rouge">git reset xxxx</code>（xxx表示一个<code class="language-plaintext highlighter-rouge">SHA</code>或者未<code class="language-plaintext highlighter-rouge">commit</code>的时候是<code class="language-plaintext highlighter-rouge">HEAD</code>） 即是执行<code class="language-plaintext highlighter-rouge">git reset --mixed xxxx</code>, 他的作用是将文件恢复到你修改过文件之后没有执行任何<code class="language-plaintext highlighter-rouge">git</code>命令的状态(文件是红色状态)。<p><code class="language-plaintext highlighter-rouge">--soft</code>参数是将文件仅仅是恢复到未commit的状态，其文件还是<code class="language-plaintext highlighter-rouge">git add</code>过的（还是绿的）。<p><code class="language-plaintext highlighter-rouge">--hard</code>就比较强势了，它会将你的文件彻底恢复到你指定的提交记录的状态，不管你是<code class="language-plaintext highlighter-rouge">add</code>过还是<code class="language-plaintext highlighter-rouge">commit</code>过还是修改过文件，统统无视。注意，执行<code class="language-plaintext highlighter-rouge">git reset --hard xxx</code>具有一定的危险性，会将你当前的修改从本机删除。<p><code class="language-plaintext highlighter-rouge">git reset --hard xxx</code>之后，文件已经从本机删除了，你所有的修改也已经被删除，但是想找回<code class="language-plaintext highlighter-rouge">hard</code>删除的文件修改记录怎么办呢？使用<code class="language-plaintext highlighter-rouge">git reflog</code><p>你的每一步<code class="language-plaintext highlighter-rouge">commit</code>和<code class="language-plaintext highlighter-rouge">reset</code>操作，<code class="language-plaintext highlighter-rouge">git</code>都会生成一个记录，这个记录可以在通过<code class="language-plaintext highlighter-rouge">git reflog</code>找到，在每个记录之前有个短<code class="language-plaintext highlighter-rouge">hash</code>，复制这个短<code class="language-plaintext highlighter-rouge">hash</code>，重新执行一遍<code class="language-plaintext highlighter-rouge">git reset --hard short_hash</code>即可。<p>注意，执行<code class="language-plaintext highlighter-rouge">git commit</code>之后这个时候的<code class="language-plaintext highlighter-rouge">HEAD</code>已经变成你提交过的文件的更改状态，再执行<code class="language-plaintext highlighter-rouge">git reset --mixed HEAD</code>或者<code class="language-plaintext highlighter-rouge">git reset --soft HEAD</code>无效（因为当前的<code class="language-plaintext highlighter-rouge">HEAD</code>就是你<code class="language-plaintext highlighter-rouge">commit</code>之后的那个点（即使你没有<code class="language-plaintext highlighter-rouge">push</code>）），如果想返回到<code class="language-plaintext highlighter-rouge">git add</code>之后，<code class="language-plaintext highlighter-rouge">git commit</code>之前的状态需要<code class="language-plaintext highlighter-rouge">git reset --soft commit_id</code>，如果返回到<code class="language-plaintext highlighter-rouge">git add</code>之前的状态，需要<code class="language-plaintext highlighter-rouge">git reset --mixed commit_id</code>， 或者直接<code class="language-plaintext highlighter-rouge">git reset commit_id</code>。<p><code class="language-plaintext highlighter-rouge">git commit</code>后悔药的另一牌子叫<code class="language-plaintext highlighter-rouge">--amend</code>，提交之后，后悔了，发现msg写错了，或者文件又修改了，不想再生成一条<code class="language-plaintext highlighter-rouge">commit</code>记录因为很丑而且显得你很菜，居然会犯这种提交信息写错的低级错误，那么运行：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">commit</span> <span class="o">--</span><span class="nx">amend</span> <span class="nx">change_file_name_after_commit</span> <span class="o">-</span><span class="nx">m</span> <span class="dl">"</span><span class="s2">新的msg</span><span class="dl">"</span>
</code></pre></div></div><p>即可。<p>后悔药吃过了，<code class="language-plaintext highlighter-rouge">git commit</code>之后确认无误就可以<code class="language-plaintext highlighter-rouge">git push</code>了。这个时候如果你当前分支所分出来的远程分支没有其他人提交更新的话，你就可以使用<code class="language-plaintext highlighter-rouge">fast forward</code> 模式，中文翻译成快进模式，直接合并进去。形象的查看合并情况可以使用：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">log</span> <span class="o">--</span><span class="nx">graph</span> <span class="o">--</span><span class="nx">pretty</span><span class="o">=</span><span class="nx">oneline</span>
</code></pre></div></div><p>如果在你分出分支期间，还有其他人也提交了分支，如果没有冲突的话那也可以直接合并，需要你先<code class="language-plaintext highlighter-rouge">git pull</code>下来，再执行<code class="language-plaintext highlighter-rouge">git push</code>。 如果有冲突的话这个时候会提示你别人的修改和你的修改有什么冲突，这个就需要你手动解决，解决完之后就<code class="language-plaintext highlighter-rouge">git add</code>, <code class="language-plaintext highlighter-rouge">git commit</code>即可。<p>合并分支：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">merge</span> <span class="nx">another_branch_name</span>
</code></pre></div></div><p>这里的情况是<code class="language-plaintext highlighter-rouge">非fast forward</code>模式，即B从A分支上分出后，作为父分支的A分支又改变了，B分支这个时候也改了点东西，再想合并回A分支的时候，就出现了现在的情况以下情况： 注意，假设你在A分支上，需要<code class="language-plaintext highlighter-rouge">merge</code>的是B分支，则<code class="language-plaintext highlighter-rouge">merg</code>过来的B分支必须是<code class="language-plaintext highlighter-rouge">git push</code>过的，如果B分支只<code class="language-plaintext highlighter-rouge">git commit</code>的分只是不会被merge的。因为<code class="language-plaintext highlighter-rouge">git merge branch_name</code>的<code class="language-plaintext highlighter-rouge">branch_name</code>是从<code class="language-plaintext highlighter-rouge">branch_name</code>的远程<code class="language-plaintext highlighter-rouge">origin</code>来<code class="language-plaintext highlighter-rouge">merge</code>的，<code class="language-plaintext highlighter-rouge">commit</code>只修改了本地的<code class="language-plaintext highlighter-rouge">HEAD</code>，没有<code class="language-plaintext highlighter-rouge">push</code>就没有修改远程<code class="language-plaintext highlighter-rouge">origin</code>。 假设B分支已经<code class="language-plaintext highlighter-rouge">git push</code>了自己的改动到远程，而本地A也<code class="language-plaintext highlighter-rouge">git add</code>了自己的改动到本地仓库，则在A分支上执行<code class="language-plaintext highlighter-rouge">git merge B</code>的时候会出现(假设改动的是<code class="language-plaintext highlighter-rouge">config.js</code>):<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Updating</span> <span class="mi">474</span><span class="nx">cfbf</span><span class="p">..</span><span class="mi">9</span><span class="nx">c94d0c</span>
<span class="nx">error</span><span class="p">:</span> <span class="nx">Your</span> <span class="nx">local</span> <span class="nx">changes</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">following</span> <span class="nx">files</span> <span class="nx">would</span> <span class="nx">be</span> <span class="nx">overwritten</span> <span class="nx">by</span> <span class="nx">merge</span><span class="p">:</span><span class="nx">config</span><span class="p">.</span><span class="nx">js</span>
<span class="nx">Please</span> <span class="nx">commit</span> <span class="nx">your</span> <span class="nx">changes</span> <span class="nx">or</span> <span class="nx">stash</span> <span class="nx">them</span> <span class="nx">before</span> <span class="nx">you</span> <span class="nx">merge</span><span class="p">.</span>
<span class="nx">Aborting</span>
</code></pre></div></div><p>意思就是合并两个分支的时候出错中断。会让你先暂存你的当前分支的修改即<code class="language-plaintext highlighter-rouge">git stash</code>或者提交你的修改即<code class="language-plaintext highlighter-rouge">git commit</code>。 之后<code class="language-plaintext highlighter-rouge">git merge</code>之后，出现冲突再手动修改，重新提交。 OK，我们先<code class="language-plaintext highlighter-rouge">git commit</code>当前的修改，再次执行<code class="language-plaintext highlighter-rouge">git merge B</code>，这个时候出现（假设冲突文件是<code class="language-plaintext highlighter-rouge">config.js</code>）：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Auto</span><span class="o">-</span><span class="nx">merging</span> <span class="nx">config</span><span class="p">.</span><span class="nx">js</span>
<span class="nx">CONFLICT</span> <span class="p">(</span><span class="nx">content</span><span class="p">):</span> <span class="nx">Merge</span> <span class="nx">conflict</span> <span class="k">in</span> <span class="nx">config</span><span class="p">.</span><span class="nx">js</span>
<span class="nx">Automatic</span> <span class="nx">merge</span> <span class="nx">failed</span><span class="p">;</span> <span class="nx">fix</span> <span class="nx">conflicts</span> <span class="nx">and</span> <span class="nx">then</span> <span class="nx">commit</span> <span class="nx">the</span> <span class="nx">result</span><span class="p">.</span>
</code></pre></div></div><p>手动解决之后,再重新<code class="language-plaintext highlighter-rouge">git add</code>，<code class="language-plaintext highlighter-rouge">git commit</code>即可。<p>注意，如果你在一个分支上修改了文件，而在<code class="language-plaintext highlighter-rouge">checkout</code>到另一个分支的时候没有发生冲突，则不会有任何提示，文件改动依然存在，因此你可以将文件在一个分支上改动后，再提交到另一个分支上。而如果在一个分支上改动文件之后，再<code class="language-plaintext highlighter-rouge">checkout</code>其他分支出现冲突的话(比如其他分支<code class="language-plaintext highlighter-rouge">git pull</code>了，或者其他分支<code class="language-plaintext highlighter-rouge">git commit</code>了相同文件的相同修改):<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">error</span><span class="p">:</span> <span class="nx">Your</span> <span class="nx">local</span> <span class="nx">changes</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">following</span> <span class="nx">files</span> <span class="nx">would</span> <span class="nx">be</span> <span class="nx">overwritten</span> <span class="nx">by</span> <span class="nx">checkout</span><span class="p">:</span>
	<span class="nx">config</span><span class="p">.</span><span class="nx">js</span>
<span class="nx">Please</span> <span class="nx">commit</span> <span class="nx">your</span> <span class="nx">changes</span> <span class="nx">or</span> <span class="nx">stash</span> <span class="nx">them</span> <span class="nx">before</span> <span class="nx">you</span> <span class="k">switch</span> <span class="nx">branches</span><span class="p">.</span>
<span class="nx">Aborting</span>
</code></pre></div></div><p>这个时候就需要你先<code class="language-plaintext highlighter-rouge">git stash</code>储藏（此<code class="language-plaintext highlighter-rouge">stash储藏</code>不是<code class="language-plaintext highlighter-rouge">git add暂存</code>，<code class="language-plaintext highlighter-rouge">stash</code>是先将文件放到一个特定的区域，等到切换完分支之后，再像一个补丁一样，应用这个<code class="language-plaintext highlighter-rouge">stash</code>到切换到的<code class="language-plaintext highlighter-rouge">checkout</code>分支，或者不应用<code class="language-plaintext highlighter-rouge">stash</code>，等切换的分上的事情做完之后，再切换回来的时候，再次应用这个<code class="language-plaintext highlighter-rouge">stash</code>，当然如果你一直不想应用你的<code class="language-plaintext highlighter-rouge">stash</code>也可以一直不应用，没有关系）. 这里说到了<code class="language-plaintext highlighter-rouge">git stash</code>，这个命令的使用场景是同时需要做两个分支的修改的时候，其中一个分支做到了一半，这个时候另一个分支也需要修改，你不可能把已经做一半的内容丢弃，又不能<code class="language-plaintext highlighter-rouge">commit</code>，因为这有可能在<code class="language-plaintext highlighter-rouge">checkout</code>过去的会造成<code class="language-plaintext highlighter-rouge">conflict</code>，因此你需要储藏<code class="language-plaintext highlighter-rouge">stash</code>： 先查看当前状态，<code class="language-plaintext highlighter-rouge">git status</code>：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">On</span> <span class="nx">branch</span> <span class="nx">optimize</span>
<span class="nx">Your</span> <span class="nx">branch</span> <span class="nx">is</span> <span class="nx">up</span><span class="o">-</span><span class="nx">to</span><span class="o">-</span><span class="nx">date</span> <span class="kd">with</span> <span class="dl">'</span><span class="s1">origin/optimize</span><span class="dl">'</span><span class="p">.</span>
<span class="nx">Changes</span> <span class="nx">not</span> <span class="nx">staged</span> <span class="k">for</span> <span class="nx">commit</span><span class="p">:</span>
  <span class="p">(</span><span class="nx">use</span> <span class="dl">"</span><span class="s2">git add &lt;file&gt;...</span><span class="dl">"</span> <span class="nx">to</span> <span class="nx">update</span> <span class="nx">what</span> <span class="nx">will</span> <span class="nx">be</span> <span class="nx">committed</span><span class="p">)</span>
  <span class="p">(</span><span class="nx">use</span> <span class="dl">"</span><span class="s2">git checkout -- &lt;file&gt;...</span><span class="dl">"</span> <span class="nx">to</span> <span class="nx">discard</span> <span class="nx">changes</span> <span class="k">in</span> <span class="nx">working</span> <span class="nx">directory</span><span class="p">)</span>

	<span class="nx">modified</span><span class="p">:</span>   <span class="nx">config</span><span class="p">.</span><span class="nx">js</span>

<span class="nx">no</span> <span class="nx">changes</span> <span class="nx">added</span> <span class="nx">to</span> <span class="nx">commit</span> <span class="p">(</span><span class="nx">use</span> <span class="dl">"</span><span class="s2">git add</span><span class="dl">"</span> <span class="nx">and</span><span class="o">/</span><span class="nx">or</span> <span class="dl">"</span><span class="s2">git commit -a</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div><p>储存一下,<code class="language-plaintext highlighter-rouge">git stash</code>:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Saved</span> <span class="nx">working</span> <span class="nx">directory</span> <span class="nx">and</span> <span class="nx">index</span> <span class="nx">state</span> <span class="nx">WIP</span> <span class="nx">on</span> <span class="nx">optimize</span><span class="p">:</span> <span class="mi">24</span><span class="nx">bf0e1</span> <span class="nx">test</span> <span class="nx">add</span>
<span class="nx">HEAD</span> <span class="nx">is</span> <span class="nx">now</span> <span class="nx">at</span> <span class="mi">24</span><span class="nx">bf0e1</span> <span class="nx">这是一个提交</span>
</code></pre></div></div><p>之后再<code class="language-plaintext highlighter-rouge">git status</code>看下:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">On</span> <span class="nx">branch</span> <span class="nx">optimize</span>
<span class="nx">Your</span> <span class="nx">branch</span> <span class="nx">is</span> <span class="nx">up</span><span class="o">-</span><span class="nx">to</span><span class="o">-</span><span class="nx">date</span> <span class="kd">with</span> <span class="dl">'</span><span class="s1">origin/optimize</span><span class="dl">'</span><span class="p">.</span>
<span class="nx">nothing</span> <span class="nx">to</span> <span class="nx">commit</span><span class="p">,</span> <span class="nx">working</span> <span class="nx">tree</span> <span class="nx">clean</span> 
</code></pre></div></div><p>这个时候可以放心的切换到其他分支，这里要说明的是，切换到其他分支的时候你也可以使用储藏的分支到当前分支（只要你不怕冲突），查看储藏列表,<code class="language-plaintext highlighter-rouge">git stash list</code>:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">stash</span><span class="p">@{</span><span class="mi">0</span><span class="p">}:</span> <span class="nx">WIP</span> <span class="nx">on</span> <span class="nx">optimize</span><span class="p">:</span> <span class="mi">24</span><span class="nx">bf0e1</span> <span class="nx">test</span> <span class="nx">add</span>
</code></pre></div></div><p>这是刚刚<code class="language-plaintext highlighter-rouge">stash</code>起来的改动，可以使用<code class="language-plaintext highlighter-rouge">git stash apply</code>应用这个最近的改动，如果<code class="language-plaintext highlighter-rouge">stash</code>的改动有好几个，那就指定<code class="language-plaintext highlighter-rouge">stash</code>的名字:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">stash</span> <span class="nx">apply</span> <span class="nx">stash</span><span class="p">@{</span><span class="mi">0</span><span class="p">}</span>
</code></pre></div></div><p>应用之后就会从储存区删除这个<code class="language-plaintext highlighter-rouge">stash</code>，如果不希望的删除的话就：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">stash</span> <span class="nx">apply</span> <span class="nx">stash_name</span> <span class="o">--</span><span class="nx">index</span>
</code></pre></div></div><p>之后再希望删除的话就：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">git</span> <span class="nx">stash</span> <span class="nx">drop</span> <span class="nx">stash_name</span>
</code></pre></div></div><p>以上两个命令不带<code class="language-plaintext highlighter-rouge">stash_name</code>的话默认删除最近的一个<code class="language-plaintext highlighter-rouge">stash</code>。<p>暂时能想到的就这么多吧，如果不熟悉，还是用<code class="language-plaintext highlighter-rouge">Sourcetree</code>吧。<h2 id="更新">更新</h2><p><code class="language-plaintext highlighter-rouge">git revert/reset/rebase</code> 只看说明是搞不懂的, 需要你自己输入命令测试一下.<p>我就喜欢为了干净整洁的提交历史而视同 <code class="language-plaintext highlighter-rouge">git rebase</code>, 但是这个命令很危险, 有一些使用场景需要注意. 而比 <code class="language-plaintext highlighter-rouge">git rebase</code> 更危险的是 <code class="language-plaintext highlighter-rouge">git reset</code>, 它会把当前项目重置到某一次提交. 而 <code class="language-plaintext highlighter-rouge">git revert</code> 就相对安全一些, 但是你想 <code class="language-plaintext highlighter-rouge">revert</code> 之前的某个提交最好需要保证你的缓存区是空的, 否则会遇到错误提示.<p>当然, <code class="language-plaintext highlighter-rouge">git</code> 命令千千万(夸张), 有一些命令是针对一些特殊场景的, 在没遇到之前可能无法理解其中的一些用法, 这个很正常.<p>比如 <code class="language-plaintext highlighter-rouge">git reset commitId</code> 即是把 <code class="language-plaintext highlighter-rouge">HEAD</code> 移动到 <code class="language-plaintext highlighter-rouge">commitId</code> 所在的地方, 你可能一头雾水, 移动 <code class="language-plaintext highlighter-rouge">HEAD</code> 有什么用? 这个命令的目的是什么? 再比如 <code class="language-plaintext highlighter-rouge">git revert commitId</code> 是把 <code class="language-plaintext highlighter-rouge">commitId</code> 的提交给移除, 而不移动 <code class="language-plaintext highlighter-rouge">HEAD</code> 的指针.<p>看代码(<code class="language-plaintext highlighter-rouge">d0b9def</code> 对应 <code class="language-plaintext highlighter-rouge">commit -m 'reset/revert test 3'</code> 这个提交, 当前 <code class="language-plaintext highlighter-rouge">HEAD</code> 在 <code class="language-plaintext highlighter-rouge">'reset/revert test 4'</code>上):<p><code class="language-plaintext highlighter-rouge">git revert d0b9def</code> 之后, 你的代码可能是这个样子的:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">reset</span><span class="o">/</span><span class="nx">revert</span> <span class="nx">test</span> <span class="mi">1</span>
<span class="nx">reset</span><span class="o">/</span><span class="nx">revert</span> <span class="nx">test</span> <span class="mi">2</span>
<span class="o">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span> <span class="nx">HEAD</span>
<span class="nx">reset</span><span class="o">/</span><span class="nx">revert</span> <span class="nx">test</span> <span class="mi">3</span>
<span class="nx">reset</span><span class="o">/</span><span class="nx">revert</span> <span class="nx">test</span> <span class="mi">4</span>
<span class="o">=======</span>
<span class="o">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span> <span class="nx">parent</span> <span class="k">of</span> <span class="nx">d0b9def</span><span class="p">...</span> <span class="nx">reset</span><span class="o">/</span><span class="nx">revert</span> <span class="nx">test</span>
</code></pre></div></div><p>在相同的 <code class="language-plaintext highlighter-rouge">HEAD</code> 上执行 <code class="language-plaintext highlighter-rouge">git reset d0b9def</code> 之后, 你的工作区可能是这个样子的:<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nx">reset</span><span class="o">/</span><span class="nx">revert</span> <span class="nx">test</span> <span class="mi">1</span>
 <span class="nx">reset</span><span class="o">/</span><span class="nx">revert</span> <span class="nx">test</span> <span class="mi">2</span>
 <span class="nx">reset</span><span class="o">/</span><span class="nx">revert</span> <span class="nx">test</span> <span class="mi">3</span>
<span class="o">+</span><span class="nx">reset</span><span class="o">/</span><span class="nx">revert</span> <span class="nx">test</span> <span class="mi">4</span>
</code></pre></div></div><p>看出移动不移动 <code class="language-plaintext highlighter-rouge">HEAD</code> 的区别了吧? <code class="language-plaintext highlighter-rouge">revert</code> 一定会让你手动解决冲突, 因为其保留的是从你 <code class="language-plaintext highlighter-rouge">commitId</code> 之前的一个父 <code class="language-plaintext highlighter-rouge">commit</code> 到当前 <code class="language-plaintext highlighter-rouge">HEAD</code> 的除了 <code class="language-plaintext highlighter-rouge">d0b9def</code> 的所有变动. 而 <code class="language-plaintext highlighter-rouge">reset</code> 不会让你解决冲突, 而是默默的移动 <code class="language-plaintext highlighter-rouge">HEAD</code> 把自 <code class="language-plaintext highlighter-rouge">d0b9def</code> 以来所有的变动都显示为文件改动, 需要你手动 <code class="language-plaintext highlighter-rouge">git add/commit</code> 一下, 当然少不了 <code class="language-plaintext highlighter-rouge">push --force</code>.<p>因此, <code class="language-plaintext highlighter-rouge">revert</code> 被设计为撤销<code class="language-plaintext highlighter-rouge">公开</code>的提交的安全方式，<code class="language-plaintext highlighter-rouge">reset</code> 被设计为重设<code class="language-plaintext highlighter-rouge">本地</code>更改。因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销。</article><div class="page-footer"><hr /> 转载请<a href="/tech/git-command.html">注明出处</a>&nbsp;&nbsp;打赏请<a href="/donate/" target="_blank">移步这里</a> <br><br> <span class="EOF">- EOF -</span> <br><br><div class="page-navigation"> <a class="prev" href="/tech/vue-simple-use.html">&laquo; Vue + Webpack 组件式开发(练习环境)初体验</a> <a class="next" href="/tech/promise-antipattern.html">[译] Promise 反面模式 &raquo;</a></div><div id="gitalk-container"></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script type="text/javascript"> window.addEventListener('load', function(){ var gitalk = new Gitalk({ clientID: 'd2b353a60fa1233163fc', clientSecret: '8091d57674976bcd60fc05261bf93c00da7e5ff4', repo: 'x_blog', owner: 'Xheldon', admin: ['Xheldon'], id: "git-command" }); gitalk.render('gitalk-container'); }); </script></main><footer> &copy; 2021 - Xheldon - Theme Powered By Xheldon <span class="footer-social"> <a href="https://twitter.com/_Xheldon" target="_blank"><i class="fab fa-twitter"></i></a> <a href="https://t.me/xheldon_saloon" target="_blank"><i class="fab fa-telegram"></i></a> <a href="https://www.zhihu.com/people/xheldon/pins" target="_blank"><i class="fa" style="font-size: 16px;line-height:2;">知乎</i></a> </span></footer></div><script type="text/javascript"> !function () { function e(t) { var n = {}; if (1 == t.nodeType) { if (t.attributes.length > 0) { n["@attributes"] = {}; for (var i = 0; i < t.attributes.length; i++) { var s = t.attributes.item(i); n["@attributes"][s.nodeName] = s.nodeValue } } } else 3 == t.nodeType && (n = t.nodeValue); var a = [].slice.call(t.childNodes).filter(function (e) { return 3 === e.nodeType }); if (t.hasChildNodes() && t.childNodes.length === a.length) n = [].slice.call(t.childNodes).reduce(function (e, t) { return e + t.nodeValue }, ""); else if (t.hasChildNodes()) for (var r = 0; r < t.childNodes.length; r++) { var o = t.childNodes.item(r), d = o.nodeName; if ("undefined" == typeof n[d]) n[d] = e(o); else { if ("undefined" == typeof n[d].push) { var c = n[d]; n[d] = [], n[d].push(c) } n[d].push(e(o)) } } return n } function t(t) { var n = e(t); return n.channel.item } var n, i = document.querySelector("#js-search"), s = document.querySelector("#js-search__input"), a = document.querySelector("#js-search__results"), r = "", o = [], d = new XMLHttpRequest; d.open("GET", "/sitemap.xml"), d.onreadystatechange = function () { if (4 == d.readyState && (200 == d.status || 304 == d.status)) { var e = (new DOMParser).parseFromString(d.responseText, "text/xml"); e = e.children[0], o = t(e) } }, d.send(), window.toggleSearch = function () { _gaq.push(["_trackEvent", "supersearch", i.classList.contains("is-active")]), i.classList.toggle("is-active"), i.classList.contains("is-active") ? s.value = "" : a.classList.add("is-hidden"), setTimeout(function () { s.focus() }, 210) }, window.addEventListener("keyup", function (e) { 27 === e.which && toggleSearch() }), window.addEventListener("keypress", function (e) { 47 !== e.which || i.classList.contains("is-active") || toggleSearch() }), s.addEventListener("input", function () { var e, t; if (r = (s.value + "").toLowerCase(), !r || r.length < 3) return n = "", void a.classList.add("is-hidden"); a.style.offsetWidth; var i; i = void 0 === o.title ? o.filter(function (e) { return -1 !== (e.title + "").toLowerCase().indexOf(r) || -1 !== (e.description + "").toLowerCase().indexOf(r) ? !0 : void 0 }) : [o], i.length || a.classList.add("is-hidden"), e = i.reduce(function (e, t) { return t.title + e }, ""), i.length && e !== n && (a.classList.remove("is-hidden"), a.innerHTML = i.map(function (e) { return t = new Date(e.pubDate), '<li><a href="' + e.link + '">' + e.title + "</a>" }).join("")), n = e }) }(); </script><link href="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/css/font-awesome.min.css" rel="stylesheet" crossorigin="anonymous"> <script> (function (i, s, o, g, r, a, m) { i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments) }, i[r].l = 1 * new Date(); a = s.createElement(o), m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m) })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga'); ga('create', 'UA-79359216-1', 'auto'); ga('send', 'pageview'); </script> <script> document.addEventListener('DOMContentLoaded',function(){ try { Array.prototype.slice.call(document.querySelectorAll('a')).forEach(function(a){ if (!a.getAttribute('target')) { let href = a.getAttribute('href'); let attrs = Object.keys(a.dataset); if (href && href.indexOf('/') && href.indexOf('#')) { a.setAttribute('target', '_blank'); } else { a.setAttribute('target', '_self'); } /* 默认情况下外链在新窗口打开, 本地链接在当前窗口打开 kramdown 可以对 url 设置特殊属性 data-open, 因此用此特性来排除需要在新窗口打开的本地链接 */ if (attrs.length) { attrs.forEach(function(attr){ switch (attr) { case 'open': a.setAttribute('target', '_blank'); break; default: break; } }); } } }); } catch (e) { console.log('新窗口打开链接失败:', e); } /*try { let toc = document.getElementById('post-toc'); if (toc) { function setPosition() { let offset = toc.parentElement.getBoundingClientRect().y; if (offset <= 50) { toc.style.position = 'fixed'; toc.style.top = '50px'; } else { toc.style.position = 'absolute'; toc.style.top = '0'; } } setPosition(); window.addEventListener('scroll', setPosition); } } catch(e) { console.log('toc滚动失败'); }*/ }); </script>
