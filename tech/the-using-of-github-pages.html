<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0,user-scalable=no"/><link rel="shortcut icon" href="/favicon.ico" /><title>免费使用私有仓库发布 GitHub Pages - Xheldon</title><meta name="author" content="Xheldon" /><meta name="description" content="免费使用私有仓库发布 GitHub Pages" /><meta name="keywords" content="免费使用私有仓库发布 GitHub Pages, Xheldon, Web" /><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"><meta content="" property="fb:app_id"><meta content="Xheldon" property="og:site_name"><meta content="免费使用私有仓库发布 GitHub Pages" property="og:title"><meta content="article" property="og:type"><meta content="会点前端，在学 Node、Electron、ProseMirror" property="og:description"><meta content="https://xheldon.com/tech/the-using-of-github-pages.html" property="og:url"><meta content="2020-10-31T14:44:30+00:00" property="article:published_time"><meta content="https://xheldon.com/about/" property="article:author"><meta content="/resource/img/logo_min.png" property="og:image"><meta content="Web" property="article:section"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@"><meta name="twitter:title" content="免费使用私有仓库发布 GitHub Pages"><meta name="twitter:url" content="https://xheldon.com/tech/the-using-of-github-pages.html"><meta name="twitter:description" content="会点前端，在学 Node、Electron、ProseMirror"><style type="text/css"> /* Project Elements */ .project-outer { display: inline-block; min-width: 30%; max-width: 45%; vertical-align: top; margin: 0 1.6%; overflow: hidden; } .project-img img { width: 100%; } h3.project-headlines { margin: 5px 0; font-size: 20px; } span.tags { font-size: 10px; border-bottom: 1px #888 dotted; margin: 0 5px; } span.tags:first-child { margin-left: 0; } span.tags:last-child { margin-right: 0; } .project-footer { clear: both; display: inline-block; width: 100%; } .project-footer .project-link { display: inline-block; position: relative; float: left; text-decoration: none; } .project-footer .project-timeline { display: inline-block; position: relative; float: right; font-size: 13px; font-style: italic; } .project-inner>a { display: block; } .project-img { width: 100%; height: 200px; display: block; background-size: contain; background-repeat: no-repeat; background-position: center center; } /** Project Tag Filters **/ .tag-group { margin: 0 0 25px 0; } span.tag-cloud { margin: 0 2px; cursor: pointer; font-size: 75%; padding: .2em .6em .3em; font-weight: 700; display: inline; } .tag-cloud.active { background: #ccc; } .project-item.not-show { display: none; } a.project-detail:hover { text-decoration: none; } a.project-detail:hover h3 { color: #428bca; }</style><link rel="stylesheet" href="/resource/css/main.css?t=20190911161844"><body><div class="container" id="container-post"><header id="header-post"> <a href="/"><img class="profile-avatar" src="/resource/img/logo_min.png" height="75px" width="75px" /></a><nav class="navlinks"><li><a class="about" href="https://42.xheldon.com/about/">我</a><li><a class="about" href="/book-list/">书单</a><li><a class="about" href="/projects/">项目</a><li><a class="about" href="/donate/">赞赏</a><li><a class="about" href="/feed.xml">订阅</a></nav><div class="search" id="js-search"> <input type="text" placeholder="搜索一下" class="search__input form-control" id="js-search__input"><ul class="search__results" id="js-search__results"></ul></div></header><main class="main-layout" id="page-post"><aside id="toc"><ul id="my_toc"><li><a href="#前言">前言</a><li><a href="#总体流程">总体流程</a><li><a href="#详细过程">详细过程</a><ul><li><a href="#层级关系">层级关系</a><li><a href="#使用别人的-step">使用别人的 step</a><li><a href="#加密数据">加密数据</a></ul><li><a href="#具体步骤">具体步骤</a><li><a href="#与-travis-的区别">与 travis 的区别</a></ul></aside><article class="post"><section class="post-header"><h1 class="post-title">免费使用私有仓库发布 GitHub Pages</h1><div> <time class="time">2020年10月31日</time> <span class="categories"> &raquo; <a href="/category/Web">Web</a> </span></div></section><div class="time-tips">注意：离本文创建时间已经过去了 <code>249</code> 天, 请注意时效性</div><h2 id="前言">前言</h2><p>最近研究了下 Github Pages 配合 Github Actions，觉得很适合自己的个人博客的场景，遂有此文。<p>我的博客之前是直接在源码放在 repo 中，使用 Github Pages 提供的默认的 Jekyll，然后设置自定义域名。但是这样有以下几个问题：<ol><li>无法隐藏源码。你的 _post 目录下的文章可以随意的复制然后放到别的地方当作他们自己的内容。<li>无法隐藏修改记录。如果你有一些内容突然不想放到博客上了，于是你把部分内容给删了，但是别人仍然可以通过访问仓库源码的历史记录查看到该文件的历史，你的修改一览无余。<li>无法使用 Gitalk。以上两个问题可以使用 Github Pro 及以上方式解决，该种付费账户的功能之一就是允许私有仓库使用 Github Pages。但是这样就无法使用 Gitalk 这种需要第三方写入 issue 的留言工具了。<li>本地与线上打包结果不一致或报错无法排查。因为 Github Pages 提供的 Jekyll 对我们来说是黑盒，因此无法排查。<li>无法使用一些自定义/三方插件。因为 Github Pages 只支持 <a href="https://pages.github.com/versions/">部分插件</a>，因此诸如可以对分类文章进行分页而不仅限于首页分页的 jekyll-paginate v2 版就无法使用。</ol><p>鉴于以上原因，因此我决定将编译后的源码作为 Github Pages 的内容，而不是源码。由于博客仓库已经有了一些 Gitalk 生成的 issue 留言，因此我又新开了一个仓库，将新仓库作为源码的存放地并设置为私有，然后将旧仓库仍然作为 Github Pages 发布的仓库，只是发布的是编译后的源码。如此以来，既可以保留原始的留言数据，又可以避免以上的几个问题。因为我每次编译源码后发布到 Github Pages 都是使用 force 推送，因此无法查看文件修改记录，在一定程度上保护了隐私，增加了复制的成本。下面是这个过程的介绍。<h2 id="总体流程">总体流程</h2><p>基本流程是，假设旧的仓库叫做 A，新的放源码的私有仓库叫做 B。则当又新的 push 发生的时候，会触发 B 仓库的 Github Actions，然后该 Actions 会将编译后的源码，即 _site 文件夹中的内容 push 到 A 仓库，而 A 仓库原本就是 Github Pages，已经自定义好了域名，因此不用做任何处理即可。<h2 id="详细过程">详细过程</h2><p>在 Github Actions 需要明确几个概念，分别是：<h3 id="层级关系">层级关系</h3><p>从大到小依次为：<ol><li>脚本本身：就是这个会被 actions 执行的 ci.yml 的文件本身。<li>任务：即配置的 jobs，jobs 默认是并行运行，可以通过 needs 关键字来设置依赖的其他 jobs。<li>步骤：即 steps，jobs 中执行的每一步，顺序执行。每个 stps 都在自己的环境上下文中运行。一个 jobs 中可以有无限个步骤。<li>操作：并非所有步骤都会运行操作，但是操作都是在步骤中运行的。操作是具体的命令，如打印当前目录、安装依赖等。</ol><h3 id="使用别人的-step">使用别人的 step</h3><p>Action 允许你使用别人写好的 step，这样你就不用自己写了，比如如果你需要 checkout 分支，则只需要：<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v2</span>
    <span class="s">with</span><span class="pi">:</span>
        <span class="na">persist-credentials</span><span class="pi">:</span> <span class="s">fasle</span> <span class="c1"># false 是用 personal token，true 是使用 GitHub token</span>
        <span class="na">fetch-depth</span><span class="pi">:</span> <span class="m">0</span>
</code></pre></div></div><p>即可。with 是相关的参数，具体可以查看该 step 的说明。<h3 id="加密数据">加密数据</h3><p>你肯定不希望在 ci 文件中暴露自己的 <a href="https://docs.github.com/cn/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token">Personal Token</a> 或者其他隐私数据被所有人看到，因此你需要另一种方式来使用之，即加密后再通过名称引用，这里需要注意的问题是加密数据之间的不同：<ol><li><a href="https://docs.github.com/cn/free-pro-team@latest/actions/reference/authentication-in-a-workflow">GITHUB_TOKEN</a>。如果你只对自己的仓库进行一些 build 或者 actions，那么你不需要在仓库设置中做任何事，在 actions 运行的时候，Github 会自动在上下文生成一个叫做 GITHUB_TOKEN 的环境变量，它可以用在需要鉴权的地方，如 push 代码到当前仓库等。<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token">Personal Token</a>。如果你当前的 ci 在 A 仓库，但是需要往 B 仓库做一些事情，那么你就需要 B 仓库的管理员生成的 Personal Token，然后分配一些权限即可。<li><a href="https://docs.github.com/cn/free-pro-team@latest/actions/reference/encrypted-secrets">自定义加密</a>。在第二步已经在 B 仓库生成了 Personal Token，然后如何在 A 仓库中使用呢？这个时候就需要用到 secret 了，即自定义加密。你需要在 A 仓库的设置中，自定义一个变量名，如 B_REPO_TOKEN 然后将刚刚拿到的 Personal Token 复制进去，然后就可以用 secret.B_REPO_TOKEN 的方式来引用了。</ol><h2 id="具体步骤">具体步骤</h2><p>上面已经说的很详细了，下面直接列出文件，挨个分析。需要用到的时候直接复制该内容稍加修改即可：<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 该 ci 的名字，可以在仓库的 Github Actions tab 看到</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">Blog Generator</span>

<span class="c1"># 触发时机</span>
<span class="na">on</span><span class="pi">:</span>
  <span class="c1"># 代码 push 到 master 分支的时候运行该 workflow</span>
  <span class="c1"># TODO：不运行 commit 信息中包含特定关键词的 push</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span> <span class="nv">master</span> <span class="pi">]</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="c1"># build-and-push 是 jobs 名字，随便取，可以有多个 jobs 默认并行</span>
  <span class="na">build-and-push</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span> <span class="c1"># 该 jobs 运行的环境</span>
    <span class="na">steps</span><span class="pi">:</span>
      <span class="c1"># 首先一般都是 checkout 当前的仓库代码，用官方的 actions/checkout@v2</span>
      <span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v2</span>
        <span class="na">with</span><span class="pi">:</span> <span class="c1"># with 表示所需要的参数</span>
          <span class="na">persist-credentials</span><span class="pi">:</span> <span class="s">fasle</span> <span class="c1"># false 是用 personal token，true 是使用 GitHub token</span>
          <span class="na">fetch-depth</span><span class="pi">:</span> <span class="m">0</span> <span class="c1"># 保证能够 push 成功</span>

      <span class="c1"># 设置 ruby 环境，这里用的也是官方的 actions</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set up Ruby</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">ruby/setup-ruby@v1</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">ruby-version</span><span class="pi">:</span> <span class="m">2.6</span>

      <span class="c1"># 安装依赖</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install dependencies</span> <span class="c1"># 操作名字，会显示在 Github Actions 的任务输出界面，方便你 debug</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">bundle install</span> <span class="c1"># 运行的命令</span>

      <span class="c1"># 打包静态资源</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build Pages</span>
        <span class="na">run</span><span class="pi">:</span> <span class="s">bundle exec jekyll build</span> 

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Add Message</span>
        <span class="na">working-directory</span><span class="pi">:</span> <span class="s">./_site</span> <span class="c1"># jekyll 默认 build 到 _site 目录，因此设置命令执行的目录为 ./_site</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span> <span class="c1"># run 后面加个 ‘|’ 然后换行可以同时执行多个命令，每行一个</span>
           <span class="s">echo "www.xheldon.com" &gt; CNAME</span>
           <span class="s">echo -e "# [Xheldon's Tech blog](https://www.xheldon.com)" &gt; README.md</span>
     
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Commit and Push</span> <span class="c1"># 将打包后的位于 _site 目录的文件 push 到 A 仓库即可</span>
        <span class="na">working-directory</span><span class="pi">:</span> <span class="s">./_site</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">git init</span>
          <span class="s">git checkout -b master</span>
          <span class="s">git add -A</span>
          <span class="s">git -c user.name='github actions by $' -c user.email='NO' commit -m 'update' </span>
          <span class="s">git push "https://${{github.actor}}:${{secrets.X_BLOG_SITE}}@github.com/Xheldon/x_blog.git" HEAD:master -f -q</span>
</code></pre></div></div><p>这里最后一步需要说明下，<code class="language-plaintext highlighter-rouge">X_BLOG_SITE</code> 即为我自定义的加密数据，值是配置的 Personal Token。另外 push 到远端的话，如果该 CI 只操作当前仓库，则不用将仓库名写死，可以用环境变量写做如下形式：<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">git push "https://${{github.actor}}:${{secrets.GITHUB_TOKEN}}@github.com/${{github.repository}}.git" HEAD:master -f -q</span>
</code></pre></div></div><p>即使用 github.XXX 来指代相关信息，可以 <a href="https://docs.github.com/cn/free-pro-team@latest/actions/reference/context-and-expression-syntax-for-github-actions#github-context">在这里</a> 查看更多上下文参数说明。<h2 id="与-travis-的区别">与 travis 的区别</h2><p>之前我用过 Travis，两者概念基本大差不差，最显著的区别就是 Github Actions 允许引用别人写好的 actions，就好比是允许你 ‘require’ 别人的包一样，你无需维护这个包，直接使用即可，玩法更多，配置也更少，复用性更强。</article><div class="page-footer"><hr /> 转载请<a href="/tech/the-using-of-github-pages.html">注明出处</a>&nbsp;&nbsp;打赏请<a href="/donate/" target="_blank">移步这里</a> <br><br> <span class="EOF">- EOF -</span> <br><br><div class="panel-body"><h4>相同分类:</h4><ul><li class="relatedPost"> <a href="/tech/optimize-of-this-site.html">博客优化技巧</a> (分类: <a href="/category/Web">Web</a>)<li class="relatedPost"> <a href="/tech/research-CORS.html">我对 CORS 的探究</a> (分类: <a href="/category/Web">Web</a>)<li class="relatedPost"> <a href="/tech/github-pages-config.html">关于本博客域名优化配置的几点说明</a> (分类: <a href="/category/Web">Web</a>)</ul></div><div class="page-navigation"> <a class="prev" href="/tech/nginx-forward-and-reverse-proxy.html">&laquo; Nginx 中的正向和反向代理</a> <a class="next" href="/tech/optimize-of-this-site.html">博客优化技巧 &raquo;</a></div><div id="gitalk-container"></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script type="text/javascript"> window.addEventListener('load', function(){ var gitalk = new Gitalk({ clientID: 'd2b353a60fa1233163fc', clientSecret: '8091d57674976bcd60fc05261bf93c00da7e5ff4', repo: 'x_blog', owner: 'Xheldon', admin: ['Xheldon'], id: "the-using-of-github-pages" }); gitalk.render('gitalk-container'); }); </script></main><footer> &copy; 2021 - Xheldon - Theme Powered By Xheldon <span class="footer-social"> <a href="https://twitter.com/_Xheldon" target="_blank"><i class="fab fa-twitter"></i></a> <a href="https://t.me/xheldon_saloon" target="_blank"><i class="fab fa-telegram"></i></a> <a href="https://www.zhihu.com/people/xheldon/pins" target="_blank"><i class="fa" style="font-size: 16px;line-height:2;">知乎</i></a> </span></footer></div><script type="text/javascript"> !function () { function e(t) { var n = {}; if (1 == t.nodeType) { if (t.attributes.length > 0) { n["@attributes"] = {}; for (var i = 0; i < t.attributes.length; i++) { var s = t.attributes.item(i); n["@attributes"][s.nodeName] = s.nodeValue } } } else 3 == t.nodeType && (n = t.nodeValue); var a = [].slice.call(t.childNodes).filter(function (e) { return 3 === e.nodeType }); if (t.hasChildNodes() && t.childNodes.length === a.length) n = [].slice.call(t.childNodes).reduce(function (e, t) { return e + t.nodeValue }, ""); else if (t.hasChildNodes()) for (var r = 0; r < t.childNodes.length; r++) { var o = t.childNodes.item(r), d = o.nodeName; if ("undefined" == typeof n[d]) n[d] = e(o); else { if ("undefined" == typeof n[d].push) { var c = n[d]; n[d] = [], n[d].push(c) } n[d].push(e(o)) } } return n } function t(t) { var n = e(t); return n.channel.item } var n, i = document.querySelector("#js-search"), s = document.querySelector("#js-search__input"), a = document.querySelector("#js-search__results"), r = "", o = [], d = new XMLHttpRequest; d.open("GET", "/sitemap.xml"), d.onreadystatechange = function () { if (4 == d.readyState && (200 == d.status || 304 == d.status)) { var e = (new DOMParser).parseFromString(d.responseText, "text/xml"); e = e.children[0], o = t(e) } }, d.send(), window.toggleSearch = function () { _gaq.push(["_trackEvent", "supersearch", i.classList.contains("is-active")]), i.classList.toggle("is-active"), i.classList.contains("is-active") ? s.value = "" : a.classList.add("is-hidden"), setTimeout(function () { s.focus() }, 210) }, window.addEventListener("keyup", function (e) { 27 === e.which && toggleSearch() }), window.addEventListener("keypress", function (e) { 47 !== e.which || i.classList.contains("is-active") || toggleSearch() }), s.addEventListener("input", function () { var e, t; if (r = (s.value + "").toLowerCase(), !r || r.length < 3) return n = "", void a.classList.add("is-hidden"); a.style.offsetWidth; var i; i = void 0 === o.title ? o.filter(function (e) { return -1 !== (e.title + "").toLowerCase().indexOf(r) || -1 !== (e.description + "").toLowerCase().indexOf(r) ? !0 : void 0 }) : [o], i.length || a.classList.add("is-hidden"), e = i.reduce(function (e, t) { return t.title + e }, ""), i.length && e !== n && (a.classList.remove("is-hidden"), a.innerHTML = i.map(function (e) { return t = new Date(e.pubDate), '<li><a href="' + e.link + '">' + e.title + "</a>" }).join("")), n = e }) }(); </script><link href="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/css/font-awesome.min.css" rel="stylesheet" crossorigin="anonymous"> <script> (function (i, s, o, g, r, a, m) { i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments) }, i[r].l = 1 * new Date(); a = s.createElement(o), m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m) })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga'); ga('create', 'UA-79359216-1', 'auto'); ga('send', 'pageview'); </script> <script> document.addEventListener('DOMContentLoaded',function(){ try { Array.prototype.slice.call(document.querySelectorAll('a')).forEach(function(a){ if (!a.getAttribute('target')) { let href = a.getAttribute('href'); let attrs = Object.keys(a.dataset); if (href && href.indexOf('/') && href.indexOf('#')) { a.setAttribute('target', '_blank'); } else { a.setAttribute('target', '_self'); } /* 默认情况下外链在新窗口打开, 本地链接在当前窗口打开 kramdown 可以对 url 设置特殊属性 data-open, 因此用此特性来排除需要在新窗口打开的本地链接 */ if (attrs.length) { attrs.forEach(function(attr){ switch (attr) { case 'open': a.setAttribute('target', '_blank'); break; default: break; } }); } } }); } catch (e) { console.log('新窗口打开链接失败:', e); } /*try { let toc = document.getElementById('post-toc'); if (toc) { function setPosition() { let offset = toc.parentElement.getBoundingClientRect().y; if (offset <= 50) { toc.style.position = 'fixed'; toc.style.top = '50px'; } else { toc.style.position = 'absolute'; toc.style.top = '0'; } } setPosition(); window.addEventListener('scroll', setPosition); } } catch(e) { console.log('toc滚动失败'); }*/ }); </script>
