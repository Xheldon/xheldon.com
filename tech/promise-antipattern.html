<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0,user-scalable=no"/><link rel="shortcut icon" href="/favicon.ico" /><title>[译] Promise 反面模式 - Xheldon</title><meta name="author" content="Xheldon" /><meta name="description" content="[译] Promise 反面模式" /><meta name="keywords" content="[译] Promise 反面模式, Xheldon, Translation" /><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"><meta content="" property="fb:app_id"><meta content="Xheldon" property="og:site_name"><meta content="[译] Promise 反面模式" property="og:title"><meta content="article" property="og:type"><meta content="会点前端，在学 Node、Electron、ProseMirror" property="og:description"><meta content="https://xheldon.com/tech/promise-antipattern.html" property="og:url"><meta content="2016-03-04T14:43:12+00:00" property="article:published_time"><meta content="https://xheldon.com/about/" property="article:author"><meta content="/resource/img/logo_min.png" property="og:image"><meta content="Translation" property="article:section"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@"><meta name="twitter:title" content="[译] Promise 反面模式"><meta name="twitter:url" content="https://xheldon.com/tech/promise-antipattern.html"><meta name="twitter:description" content="会点前端，在学 Node、Electron、ProseMirror"><style type="text/css"> /* Project Elements */ .project-outer { display: inline-block; min-width: 30%; max-width: 45%; vertical-align: top; margin: 0 1.6%; overflow: hidden; } .project-img img { width: 100%; } h3.project-headlines { margin: 5px 0; font-size: 20px; } span.tags { font-size: 10px; border-bottom: 1px #888 dotted; margin: 0 5px; } span.tags:first-child { margin-left: 0; } span.tags:last-child { margin-right: 0; } .project-footer { clear: both; display: inline-block; width: 100%; } .project-footer .project-link { display: inline-block; position: relative; float: left; text-decoration: none; } .project-footer .project-timeline { display: inline-block; position: relative; float: right; font-size: 13px; font-style: italic; } .project-inner>a { display: block; } .project-img { width: 100%; height: 200px; display: block; background-size: contain; background-repeat: no-repeat; background-position: center center; } /** Project Tag Filters **/ .tag-group { margin: 0 0 25px 0; } span.tag-cloud { margin: 0 2px; cursor: pointer; font-size: 75%; padding: .2em .6em .3em; font-weight: 700; display: inline; } .tag-cloud.active { background: #ccc; } .project-item.not-show { display: none; } a.project-detail:hover { text-decoration: none; } a.project-detail:hover h3 { color: #428bca; }</style><link rel="stylesheet" href="/resource/css/main.css?t=20190911161844"><body><div class="container" id="container-post"><header id="header-post"> <a href="/"><img class="profile-avatar" src="/resource/img/logo_min.png" height="75px" width="75px" /></a><nav class="navlinks"><li><a class="about" href="https://42.xheldon.com/about/">我</a><li><a class="about" href="/book-list/">书单</a><li><a class="about" href="/projects/">项目</a><li><a class="about" href="/donate/">赞赏</a><li><a class="about" href="/feed.xml">订阅</a></nav><div class="search" id="js-search"> <input type="text" placeholder="搜索一下" class="search__input form-control" id="js-search__input"><ul class="search__results" id="js-search__results"></ul></div></header><main class="main-layout" id="page-post"><aside id="toc"><ul id="my_toc"><li><a href="#嵌套promises">嵌套Promises</a><li><a href="#中断的链式调用">中断的链式调用</a><li><a href="#混乱的集合">混乱的集合</a><li><a href="#幽灵promise">幽灵Promise</a><li><a href="#饥渴的错误处理函数">饥渴的错误处理函数</a><li><a href="#被遗忘的promise">被遗忘的Promise</a></ul></aside><article class="post"><section class="post-header"><h1 class="post-title">[译] Promise 反面模式</h1><div> <time class="time">2016年03月04日</time> <span class="categories"> &raquo; <a href="/category/Translation">Translation</a> </span></div></section><div class="time-tips">注意：离本文创建时间已经过去了 <code>1951</code> 天, 请注意时效性</div><p>最近在看<code class="language-plaintext highlighter-rouge">Promise</code>相关的东西，看到了这篇文章，觉得很不错，遂记录下来。<p><code class="language-plaintext highlighter-rouge">Promises</code>本身是很简单的，前提是你得找得到头绪，下面是几个关于Promise的容易困惑的知识点来验证你是否真的掌握了<code class="language-plaintext highlighter-rouge">Promise</code>。其中的几个真的曾经让我抓狂过。<h2 id="嵌套promises">嵌套Promises</h2><p>你有一捆的Promises互相嵌套着：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">loadSomething</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">something</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">loadAnotherthing</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">another</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">DoSomethingOnThem</span><span class="p">(</span><span class="nx">something</span><span class="p">,</span> <span class="nx">another</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div><p>你这么做的原因是你需要处理这两个Promises的结果，所以你不能链式调用他们因为<code class="language-plaintext highlighter-rouge">then()</code>方法只接受上一个<code class="language-plaintext highlighter-rouge">then()</code>返回的结果。（意思是这两个<code class="language-plaintext highlighter-rouge">Promise</code>是需要同时处理没有先后关系的，但是<code class="language-plaintext highlighter-rouge">then</code>却有个先后关系，如果前者<code class="language-plaintext highlighter-rouge">throw</code> <code class="language-plaintext highlighter-rouge">error</code>直接进入<code class="language-plaintext highlighter-rouge">catch</code>处理环节）<p>呵呵，其实你这么写的真正原因是你不知道<code class="language-plaintext highlighter-rouge">all()</code>方法：<p>解决这种丑陋写法的方案：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">q</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">loadSomething</span><span class="p">(),</span> <span class="nx">loadAnotherThing</span><span class="p">()])</span>
  <span class="p">.</span><span class="nx">spread</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">something</span><span class="p">,</span> <span class="nx">another</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">DoSomethingOnThem</span><span class="p">(</span><span class="nx">something</span><span class="p">,</span> <span class="nx">another</span><span class="p">);</span>
  <span class="p">});</span>
</code></pre></div></div><p>更简洁了。<code class="language-plaintext highlighter-rouge">q.all()</code>返回一个<code class="language-plaintext highlighter-rouge">promise</code>对象，并将这个结果结合成一个数组并传递给<code class="language-plaintext highlighter-rouge">resolve</code>方法供之后的<code class="language-plaintext highlighter-rouge">then</code>方法调用，<code class="language-plaintext highlighter-rouge">spread()</code>方法将会分割这个数组为几个数组长度的参数传递给其中的<code class="language-plaintext highlighter-rouge">DoSomethingOnThem</code>函数。<p>（注：<code class="language-plaintext highlighter-rouge">Promise.all()</code>接受一个数组作为参数,数组元素为<code class="language-plaintext highlighter-rouge">promise</code>,元素之前没有先后顺序,同时执行,最后传递给<code class="language-plaintext highlighter-rouge">then</code>方法的值为各个<code class="language-plaintext highlighter-rouge">promise</code>方法<code class="language-plaintext highlighter-rouge">return</code>值的数组。这里作者使用的是<code class="language-plaintext highlighter-rouge">node</code>中的一个模块<code class="language-plaintext highlighter-rouge">q</code>作为示例)<h2 id="中断的链式调用">中断的链式调用</h2><p>  假设你有这样一段代码：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">anAsyncCall</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">doSomethingAsync</span><span class="p">();</span>
  <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">somethingComplicated</span><span class="p">();</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">promise</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>这段代码的问题是，出现在<code class="language-plaintext highlighter-rouge">somethingComplicated()</code>函数的<code class="language-plaintext highlighter-rouge">error</code>都不会被捕获。<code class="language-plaintext highlighter-rouge">Promises</code>意味着能够链式调用（不然还叫什么<code class="language-plaintext highlighter-rouge">then</code>，直接<code class="language-plaintext highlighter-rouge">done</code>就行了）每一个被调用的<code class="language-plaintext highlighter-rouge">then()</code>方法返回一个新的<code class="language-plaintext highlighter-rouge">promise</code>，这个新的<code class="language-plaintext highlighter-rouge">promise</code>是会被下一个<code class="language-plaintext highlighter-rouge">then()</code>方法继续调用的。正常来说，最后一个调用应该是<code class="language-plaintext highlighter-rouge">catch()</code>方法，出现在链式调用任何地方的任何<code class="language-plaintext highlighter-rouge">error</code>都会被它捕获并处理。<p>在上面的的代码中，链式调用在你返回第一个<code class="language-plaintext highlighter-rouge">promise</code>而不是返回一个<code class="language-plaintext highlighter-rouge">then</code>处理后的新的的<code class="language-plaintext highlighter-rouge">promise</code>给最后一个<code class="language-plaintext highlighter-rouge">then</code>调用的时候中断了（即<code class="language-plaintext highlighter-rouge">then</code>不改变原有的<code class="language-plaintext highlighter-rouge">promise</code>，它只处理它，然后返回一个新的<code class="language-plaintext highlighter-rouge">promise</code>）。 解决这个问题的方案：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">anAsyncCall</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">doSomethingAsync</span><span class="p">();</span>
  <span class="k">return</span> <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">somethingComplicated</span><span class="p">()</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div><p>记住，总是返回最后一个<code class="language-plaintext highlighter-rouge">then()</code>的结果（以能够使用链式调用）。<h2 id="混乱的集合">混乱的集合</h2><p>你有一组元素的数组，你想对这个数组的每个元素之执行一些异步操作。所以你发现你需要做一些涉及到递归调用的事情。<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">workMyCollection</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">resultArr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="kd">function</span> <span class="nx">_recursive</span><span class="p">(</span><span class="nx">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">idx</span> <span class="o">&gt;=</span> <span class="nx">resultArr</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span> <span class="nx">resultArr</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">doSomethingAsync</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">idx</span><span class="p">]).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">resultArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">_recursive</span><span class="p">(</span><span class="nx">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">_recursive</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>额。。这段代码不是很直观，问题的关键在与，当你不知道有多长的链式调用的时候，链式调用就变成一个意见痛苦的事情。除非你知道(<code class="language-plaintext highlighter-rouge">JavaScript ES5+</code>原生的数组方法)<code class="language-plaintext highlighter-rouge">map()</code>和<code class="language-plaintext highlighter-rouge">reduce()</code><p>解决方案： 记住，<code class="language-plaintext highlighter-rouge">q.all</code>参数是一个由<code class="language-plaintext highlighter-rouge">promise</code>构成的数组，同时它会把结果放到一个数组中并传给<code class="language-plaintext highlighter-rouge">resolve</code>方法。我们可以简单的使用数组元素的map方法来对每个数组中的元素执行这个异步调用方法，像下面这样：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">workMyCollection</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">q</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">doSomethingAsync</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">}));</span>
<span class="p">}</span>
</code></pre></div></div><p>不像开始那个并不是什么解决方案的递归调用，这段代码将同步调用数组中的每个元素传递给一个异步调用函数。明显在时间上更有效率一些。 如果你需要按顺序返回<code class="language-plaintext highlighter-rouge">promises</code>，你可以使用<code class="language-plaintext highlighter-rouge">reduce</code>：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">workMyCollection</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">promise</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">doSomethingAsyncWithResult</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">},</span> <span class="nx">q</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div><p>看起来不是很简单明了，但是确实比最开始的那个简洁多了。（Not quite as tidy, but certainly tidier.）<h2 id="幽灵promise">幽灵Promise</h2><p>有一个确定的方法（意思是已经在开始执行Promise时就给出此方法，而不是在执行中由结果来确定的方法—译者注），有时候需要异步调用，有时候又不需要。因此你为了应对这两种情况只创建了一个promise仅仅是为了保持异步和非异步的情况下代码一致（以便于抽象和解耦—译者注），即使这种情况实际只可能出现其中一种。<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">promise</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">asyncCallNeeded</span><span class="p">)</span>
  <span class="nx">promise</span> <span class="o">=</span> <span class="nx">doSomethingAsync</span><span class="p">();</span>
<span class="k">else</span>
  <span class="nx">promise</span> <span class="o">=</span> <span class="nx">Q</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">doSomethingCool</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div></div><p>以上这段代码在反面模式中并不算最糟糕的地方，但是却应该写的更清晰一些—用<code class="language-plaintext highlighter-rouge">Q()</code>来包裹<code class="language-plaintext highlighter-rouge">value</code>或<code class="language-plaintext highlighter-rouge">promise</code>。Q()方法即接受一个值也接受一个<code class="language-plaintext highlighter-rouge">promise</code>作为参数：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Q</span><span class="p">(</span><span class="nx">asyncCallNeeded</span> <span class="p">?</span> <span class="nx">doSomethingAsync</span><span class="p">()</span> <span class="p">:</span> <span class="mi">42</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span>
  <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
    <span class="nx">doSomethingGood</span><span class="p">();</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span>
    <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">handleTheError</span><span class="p">();</span>
    <span class="p">});</span>
</code></pre></div></div><p>备注：开始的时候我在这个情况下建议使用<code class="language-plaintext highlighter-rouge">Q.when()</code>，多亏了Kris Kowal同学在评论中的建议把我从错误中拯救出来。不要使用<code class="language-plaintext highlighter-rouge">Q.when()</code>，只使用<code class="language-plaintext highlighter-rouge">Q()</code>就够了，后者更清晰一些。<h2 id="饥渴的错误处理函数">饥渴的错误处理函数</h2><blockquote><p>小节标题意思是在<code class="language-plaintext highlighter-rouge">then</code>中同时设置<code class="language-plaintext highlighter-rouge">fulfilled</code>和<code class="language-plaintext highlighter-rouge">rejected</code>，以期能够使用<code class="language-plaintext highlighter-rouge">rejected</code>函数处理同样作为<code class="language-plaintext highlighter-rouge">then</code>函数参数的<code class="language-plaintext highlighter-rouge">fulfilled</code>中的错误，但是这是不可能的，<code class="language-plaintext highlighter-rouge">fulfilled</code>中的<code class="language-plaintext highlighter-rouge">error</code>只能传递给下一个<code class="language-plaintext highlighter-rouge">then()</code>而不能在当前被<code class="language-plaintext highlighter-rouge">rejected</code>函数处理，所以这小节的标题为『过度渴望』—它虽然渴望处理错误，但是错误永远不会传递给它让他处理—译者注</blockquote><p><code class="language-plaintext highlighter-rouge">then()</code>方法接受两个参数，对<code class="language-plaintext highlighter-rouge">fulfilled</code>状态的操作函数和对<code class="language-plaintext highlighter-rouge">rejected</code>状态操作函数。你可能写过下面这种代码：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">somethingAsync</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span>
  <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">somethingElseAsync</span><span class="p">();</span>
  <span class="p">},</span>
  <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">handleMyError</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div><p>这么写的问题是，发生在<code class="language-plaintext highlighter-rouge">fulfilled</code>状态的的<code class="language-plaintext highlighter-rouge">error</code>不会传递给错误处理函数。 解决这个问的的方法是，确保错误处理函数在一个独立的then方法中：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">somethingAsync</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">somethingElseAsync</span><span class="p">();</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span>
    <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">handleMyError</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="p">});</span>
</code></pre></div></div><p>或者使用<code class="language-plaintext highlighter-rouge">catch()</code>：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">somethingAsync</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">somethingElseAsync</span><span class="p">();</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">handleMyError</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="p">});</span>
</code></pre></div></div><p>这样可以确保任何发生在链式调用中的<code class="language-plaintext highlighter-rouge">error</code>都能得到处理。<h2 id="被遗忘的promise">被遗忘的Promise</h2><p>你调用一个方法，返回一个<code class="language-plaintext highlighter-rouge">promise</code>，然而你忘记了这个<code class="language-plaintext highlighter-rouge">promise</code>，然后又创建了一个<code class="language-plaintext highlighter-rouge">promise</code>：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">deferred</span> <span class="o">=</span> <span class="nx">Q</span><span class="p">.</span><span class="nx">defer</span><span class="p">();</span>
<span class="nx">doSomethingAsync</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span> <span class="o">=</span> <span class="nx">manipulateMeInSomeWay</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
  <span class="nx">deferred</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">deferred</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">return</span> <span class="nx">deferred</span><span class="p">.</span><span class="nx">promise</span><span class="p">;</span>
</code></pre></div></div><p>这段代码真的是把<code class="language-plaintext highlighter-rouge">promsie</code>的简洁特性抛弃的一干二净—有太多无用的代码了。 解决方案是，仅仅返回<code class="language-plaintext highlighter-rouge">promise</code>即可：<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="nx">doSomethingAsync</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">manipulateMeInSomeWay</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div></article><div class="page-footer"><hr /> 转载请<a href="/tech/promise-antipattern.html">注明出处</a>&nbsp;&nbsp;打赏请<a href="/donate/" target="_blank">移步这里</a> <br><br> <span class="EOF">- EOF -</span> <br><br><div class="panel-body"><h4>相同分类:</h4><ul><li class="relatedPost"> <a href="/tech/prosemirror-guide-chinese.html">[译] ProseMirror 中文指南</a> (分类: <a href="/category/Translation">Translation</a>)</ul></div><div class="page-navigation"> <a class="prev" href="/tech/git-command.html">&laquo; git 常用命令总结</a> <a class="next" href="/tech/weibo-jssdk.html">新浪微博JS SDK API的使用 &raquo;</a></div><div id="gitalk-container"></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script type="text/javascript"> window.addEventListener('load', function(){ var gitalk = new Gitalk({ clientID: 'd2b353a60fa1233163fc', clientSecret: '8091d57674976bcd60fc05261bf93c00da7e5ff4', repo: 'x_blog', owner: 'Xheldon', admin: ['Xheldon'], id: "promise-antipattern" }); gitalk.render('gitalk-container'); }); </script></main><footer> &copy; 2021 - Xheldon - Theme Powered By Xheldon <span class="footer-social"> <a href="https://twitter.com/_Xheldon" target="_blank"><i class="fab fa-twitter"></i></a> <a href="https://t.me/xheldon_saloon" target="_blank"><i class="fab fa-telegram"></i></a> <a href="https://www.zhihu.com/people/xheldon/pins" target="_blank"><i class="fa" style="font-size: 16px;line-height:2;">知乎</i></a> </span></footer></div><script type="text/javascript"> !function () { function e(t) { var n = {}; if (1 == t.nodeType) { if (t.attributes.length > 0) { n["@attributes"] = {}; for (var i = 0; i < t.attributes.length; i++) { var s = t.attributes.item(i); n["@attributes"][s.nodeName] = s.nodeValue } } } else 3 == t.nodeType && (n = t.nodeValue); var a = [].slice.call(t.childNodes).filter(function (e) { return 3 === e.nodeType }); if (t.hasChildNodes() && t.childNodes.length === a.length) n = [].slice.call(t.childNodes).reduce(function (e, t) { return e + t.nodeValue }, ""); else if (t.hasChildNodes()) for (var r = 0; r < t.childNodes.length; r++) { var o = t.childNodes.item(r), d = o.nodeName; if ("undefined" == typeof n[d]) n[d] = e(o); else { if ("undefined" == typeof n[d].push) { var c = n[d]; n[d] = [], n[d].push(c) } n[d].push(e(o)) } } return n } function t(t) { var n = e(t); return n.channel.item } var n, i = document.querySelector("#js-search"), s = document.querySelector("#js-search__input"), a = document.querySelector("#js-search__results"), r = "", o = [], d = new XMLHttpRequest; d.open("GET", "/sitemap.xml"), d.onreadystatechange = function () { if (4 == d.readyState && (200 == d.status || 304 == d.status)) { var e = (new DOMParser).parseFromString(d.responseText, "text/xml"); e = e.children[0], o = t(e) } }, d.send(), window.toggleSearch = function () { _gaq.push(["_trackEvent", "supersearch", i.classList.contains("is-active")]), i.classList.toggle("is-active"), i.classList.contains("is-active") ? s.value = "" : a.classList.add("is-hidden"), setTimeout(function () { s.focus() }, 210) }, window.addEventListener("keyup", function (e) { 27 === e.which && toggleSearch() }), window.addEventListener("keypress", function (e) { 47 !== e.which || i.classList.contains("is-active") || toggleSearch() }), s.addEventListener("input", function () { var e, t; if (r = (s.value + "").toLowerCase(), !r || r.length < 3) return n = "", void a.classList.add("is-hidden"); a.style.offsetWidth; var i; i = void 0 === o.title ? o.filter(function (e) { return -1 !== (e.title + "").toLowerCase().indexOf(r) || -1 !== (e.description + "").toLowerCase().indexOf(r) ? !0 : void 0 }) : [o], i.length || a.classList.add("is-hidden"), e = i.reduce(function (e, t) { return t.title + e }, ""), i.length && e !== n && (a.classList.remove("is-hidden"), a.innerHTML = i.map(function (e) { return t = new Date(e.pubDate), '<li><a href="' + e.link + '">' + e.title + "</a>" }).join("")), n = e }) }(); </script><link href="https://cdn.jsdelivr.net/gh/xheldon/x_blog-static@master/css/font-awesome.min.css" rel="stylesheet" crossorigin="anonymous"> <script> (function (i, s, o, g, r, a, m) { i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments) }, i[r].l = 1 * new Date(); a = s.createElement(o), m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m) })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga'); ga('create', 'UA-79359216-1', 'auto'); ga('send', 'pageview'); </script> <script> document.addEventListener('DOMContentLoaded',function(){ try { Array.prototype.slice.call(document.querySelectorAll('a')).forEach(function(a){ if (!a.getAttribute('target')) { let href = a.getAttribute('href'); let attrs = Object.keys(a.dataset); if (href && href.indexOf('/') && href.indexOf('#')) { a.setAttribute('target', '_blank'); } else { a.setAttribute('target', '_self'); } /* 默认情况下外链在新窗口打开, 本地链接在当前窗口打开 kramdown 可以对 url 设置特殊属性 data-open, 因此用此特性来排除需要在新窗口打开的本地链接 */ if (attrs.length) { attrs.forEach(function(attr){ switch (attr) { case 'open': a.setAttribute('target', '_blank'); break; default: break; } }); } } }); } catch (e) { console.log('新窗口打开链接失败:', e); } /*try { let toc = document.getElementById('post-toc'); if (toc) { function setPosition() { let offset = toc.parentElement.getBoundingClientRect().y; if (offset <= 50) { toc.style.position = 'fixed'; toc.style.top = '50px'; } else { toc.style.position = 'absolute'; toc.style.top = '0'; } } setPosition(); window.addEventListener('scroll', setPosition); } } catch(e) { console.log('toc滚动失败'); }*/ }); </script>
